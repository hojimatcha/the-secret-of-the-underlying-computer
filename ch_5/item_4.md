## 5.4 봉화희제후와 메모리 장벽

> [!NOTE] 메모리 가시성
> 멀티 스레드 환경에서 한 스레드가 메모리를 변경 했을 때 다른 스레드에서 그 변경된 값을 즉시 보게 하는 것

> [!NOTE] 메모리 장벽
> 메모리 가시성을 확보하고 메모리 연산 순서를 제어하는 것

메모리 가시성에 대한 문제를 알아봅시다. <br />

전역 변수 X와 Y가 각각 초깃값이 0이라 가정합니다. <br />
이 때 스레드 두 개가 동시에 다음의 코드를 실행한다고 가정해봅니다. <br />

| Thread1              | Thread2              |
| -------------------- | -------------------- |
| X = 1; <br /> a = Y; | Y = 1; <br /> b = X; |

이 때 각각 a와 b의 마지막 값은 상황에 따라 다음과 같이 달라질 수 있습니다. <br />

1. 스레드 1이 먼저 실행되는 경우 a = 0, b = 1
2. 스레드 2가 먼저 실행되는 경우 a = 1, b = 0
3. 스레드 1과 스레드 2가 동시에 코드의 첫 줄을 실행하는 경우 a = 1, b = 1
4. x86 플랫폼에서 실행한 경우 a = 0, b = 0 일 가능성이 있습니다.

<br />

### 5.4.1 명령어의 비순차적 실행: 컴파일러와 OoOE

CPU의 성능 향상을 위해 명령어의 비순차적 실행이 일어날 수 있습니다. <br />
이는 아래에 두 단계를 거칩니다.

1. 기계 명령어를 생성하는 단계: 컴파일 중에 명령어를 재정렬
2. CPU가 명령어를 실행하는 단계: 실행 중에 명령어가 비순차적 실행

컴파일러는 기계 명령어를 변환할 때 이러한 수작-비순차적 실행-을 부릴 수 있습니다.

<br />

아래의 코드예시를 통해 알아봅시다.

```cpp
int a;
int b;

void main() {
  a = b + 100;
  b = 200;
}
```

<br />

gcc 기본 컴파일 옵션으로 컴파일 한 경우

```
# %eax = b
# %eax = %eax + 100
# a = %eax
# b = 200
```

<br />

-O2 선택사항을 적용하여 컴파일러가 코드를 최적화 하도록 한 경우

```
# %eax = b
# b = 200
# %eax = %eax + 100
# a = %eax
```

`b = 200` 코드 줄이 `a = b + 100` 줄 보다 앞으로 옮겨간 것을 확인할 수 있습니다.<br />
이 코드가 오류가 나지 않는 이유는 컴파일러가 b를 변경하기 전 b의 원래 값을 레지스터에 저장해두었기 때문입니다.<br />
이것이 컴파일러가 명령어를 재정렬 하는 동작의 예시입니다.<br />

CPU는 지금까지 다음과 같이 작업한다고 여겨 왔습니다.

<br />

1. 기계 명령어를 가져온다.
2. 명령어의 피연산자가 레지스터에 저장되어 있지 않다면 피연산자가 메모리에서 레지스터로 저장될 때까지 기다린다.<br />(이 과정은 CPU 속도에 비해 메모리 접근 속도가 매우 느리기 때문에 발생한다)
3. 피연산자가 레지스터에 저장된 준비 완료 상태라면 실행단계를 거친다.
4. 데이터가 이미 준비되었다면 명령어를 실행한다.
5. 실행결과를 다시 기록한다.

<br />

이 명령어 실행 방법은 피연산자가 아직 준비되지 않은 경우 CPU가 반드시 대기해야 하므로 비효율적입니다.<br />
따라서 아래와 같은 개선을 통해 CPU를 최적화 시킬 수 있습니다.

<br />

1. 기계 명령어를 가져온다.
2. 명령어를 대기열에 넣고 명령어이 필요한 피연산자를 읽는다.
3. 명령어는 대기열에서 피연산자의 준비가 완료될 때 까지 기다린다.
4. 피연산자가 레지스터에 저장된 준비 완료 상태라면 실행단계를 거친다.
5. 기계 명령어를 실행한 실행결과를 대기열에 넣는다.
6. 이전 명령어의 실행결과가 기록될 때 까지 기다렸다가 현재 명령어의 실행결과를 기록한다.<br />(명령어의 원래 실행 순서에 따라 유효한 결과를 얻기 위함)

<br />

CPU와 메모리 사이의 속도차이가 크기 때문에 엄격한 순서대로 실행 시,<br />
명령어가 의존하는 피연산자를 기다리는 동안 파이프 라인 내부에 '빈 공간'인 슬롯이 생깁니다.<br />
이때 준비 완료된 다른 명령어로 슬롯을 메꾼다면 실행속도를 높여 파이프라인을 최대한 활용할 수 있게 됩니다.<br />
이러한 엄격한 순서가 아닌 실행을 **비순차적 명령어 처리(Out of Order Exception, OoOE)**라고 합니다.

이는 전후 관계의 두 명령어가 서로 어떤 의존 관계도 없을 때에 한해 OoOE가 발생함을 시사합니다.<br />
하지만 모든 CPU가 이 기능을 가지고 있지는 않다는 것을 알아두어야 합니다.

<br />

### 5.4.2 캐시도 고려해야 한다.

CPU의 각 코어마다 L1캐시, L2캐시는 별도로 존재합니다.<br />
L3캐시와 메모리는 모든 코어가 공유합니다.<br />

**어떻게 캐시를 갱신**하고 **캐시의 일관성을 유지**시킬까요?<br />
이는 비교적 시간을 많이 소모하는 작업이며 CPU는 이 작업 전 반드시 대기상태를 중지해야만 합니다.

<br />

> [!NOTE] 저장버퍼
> CPU와 보조기억장치 사이에 사용되는 임시 저장 공간으로 캐시에 작업해야 하는 대기열이 추가되는 장소

<br />

CPU의 명령어 실행 과정과 기록 작업은 비동기 과정으로 이루어집니다.<br />
저장버퍼를 사용하여 기록 작업이 있는 경우 저장 버퍼의 대기열에 직접 기록하고, 캐시를 즉시 갱신하지 않습니다.<br />
이때 CPU는 캐시 갱신을 기다리지 않고 다음 명령어를 계속 실행하게 됩니다.<br />

즉, 이 저장버퍼를 사용하면 캐시 갱신은 하지 않았더라도 저장 버퍼에 있기 때문에<br />
캐시 갱신을 기다릴 필요 없이 바로 다음 줄을 실행합니다.<br />
이러한 이유로 스레드의 외부에서 바라볼 때에는 실행의 순서가 마치 다른 것 처럼 느껴질 수 있습니다.<br />

즉, **비순차적 실행은 자기 자신 이외의 다른 코어가 해당 코어를 바라 볼 때 나타나는 현상**일 뿐입니다.<br />
(마치 상대성 이론 같네요.)
따라서 **단일 스레드 환경에서 프로그래밍 한다면 비순차적 실행을 신경 쓸 필요가 없습니다**.

<br />

> [!NOTE] 잠금 없는 프로그래밍 lock-free programming
> 잠금을 통한 보호를 사용하지 않는 상태에서 다중 스레드의 공유 리스소를 처리하는 것 <br />
> 보통 다중 스레드의 공유 리소스를 사용하는 작업은 잠금을 통한 보호가 필요하다고 이야기 하지만<br />
> 실제로는 잠금이 반드시 필요한 것은 아닙니다.<br />

> [!NOTE] 비교와 교환 알고리즘 (CAS algorithm, compare-and-swap)
> 이를 통해 잠금 없이도 공유 리소스에 접근할 수 있습니다.<br />
> 동기화를 달성하기 위해 멀티 스레딩에 사용하는 원자적 명령어 입니다.<br />
> 실행되거나 실행되지 않은 상태 두가지 상태만 존재합니다.<br />
> 메모리 위치의 내용을 주어진 값과 비교하고 동일한 경우에만 해당 메모리 위치의 내용을 새로운 값으로 수정할 수 있습니다.

<br />

앞에서 언급한 비순차적 명령어 실행 문제는 어떻게 해결하면 좋을까요?<br />
이는 구체적인 기계 명령어인 **메모리 장벽(memory barrier)** 을 사용하여 해결합니다.<br />

<br />

> [!NOTE] 메모리 장벽
> 특정 코어를 다른 코어가 바라보았을 때 언행이 일치하도록 하는 것이 목적입니다.<br />
> 메모리는 읽기(Load)와 쓰기(Store) 단 두가지 유형의 작업만 존재합니다.<br />
> LoadLoad, LoadStore, StoreLoad, StoreStore 4가지의 메모리 장벽 유형이 존재합니다.<br />
> 이 모든 이름은 비순차적 실행을 금지한다는 의미를 갖습니다.<br />

<br />

### 5.4.3 네 가지 메모리 장벽 유형

- `LoadLoad`
  - CPU가 더 높은 성능을 위해 Load 명령어를 미리 실행하는 것을 방지합니다.
- `StoreStore`
  - CPU가 더 높은 성능을 위해 Store 명령어를 미리 실행하는 것을 방지합니다.
  - 변수의 갱신 순서와 코드 순서가 일치하게 됩니다.
- `LoadStore`
  - 쓰기 작업(`Store`)은 읽기 작업(`Load`)보다 상대적으로 무겁습니다.
  - 하지만 `Load` 명령어가 캐시에 적중하지 못하면 쓰기 작업(`Store`)이 더 빠르게 이루어질 수 있습니다.
  - 이러한 실행을 방지하기 위해 `Load` 후 `Store` 실행 되었음을 보장하기 위한 장벽을 추가합니다.
- `StoreLoad`
  - 쓰기 명령어를 실행할 때 읽기 명령어를 먼저 실행하는 것을 방지합니다.
  - 메모리 장벽 중 가장 무거운 작업입니다.
  - 이 장벽은 CPU가 쓰기 명령어(`Store`)를 실행할 때 쓰기 명령 작업이 얼마나 복잡하든, 대기해야 하는 시간이 얼마나 길든 간에 이 유휴시간 동안 CPU는 다음에 오는 관련 없는 읽기 작업(`Load`)을 미리 실행할 수 없습니다.

<br />

> [!TIP] StoreLoad 메모리 장벽과 StoreStore 메모리 장벽 사이의 차이
> `StoreLoad` 메모리 장벽은 장벽이 실행된 후<br />
> 다른 코어가 메모리 장벽 이전의 변수를 읽었을 때 반드시 최신값임을 보장합니다.<br /> > `StoreStore` 메모리 장벽은 장벽이 실행된 후<br />
> 다른 코어가 메모리 장벽 이전의 변수를 읽었을 때 곧바로 최신값이라는 것을 보장하지 않습니다.<br /> > `StoreStore` 메모리 장벽은 갱신 순서와 코드 순서가 일치하는 것만 보장합니다.<br />
> 다른 코어가 즉시 최신값을 확인하는 것은 보장해 주지 않습니다.<br />

<br />

### 5.4.4 획득-해제 의미론

다중 스레드 프로그래밍을 사용할 때 프로그래머는 아래의 두가지 문제에 직면합니다.

1. 공유 데이터에 대한 상호 배타적 접근
2. 스레드 간 동기화 문제

획득-해제 의미론은 스레드 간 동기화 문제를 해결하는데 사용됩니다.<br />

- 획득 의미론: 메모리 읽기 작업
  - 이번 `Load` 뒤에 있는 모든 메모리 작업은 이번 `Load` 작업이 완료되기 전까지 실행 불가능
- 해제 의미론: 메모리 쓰기 작업
  - 이번 `Store` 앞에 있는 모든 메모리 작업은 이번 `Store` 작업 이후에는 실행 불가능

<br />

- `LoadLoad` - `LoadStore` : 획득 의미론
- `StoreStore` - `StoreLoad` : 해제 의미론

획득-해제론을 얻기 위해 `StoreLoad`와 같은 무거운 메모리 장벽 없이도 나머지 세 종류의 메모리 장벽만으로도 같은 효과를 얻을 수 있습니다.
