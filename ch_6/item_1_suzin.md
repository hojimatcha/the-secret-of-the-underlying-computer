# 6. 입출력이 없는 컴퓨터가 있을까?

인간과 컴퓨터는 상호작용하기 위해 모니터, 키보드, 터치 스크린, 그래픽 인터페이스 등을 도구로 사용합니다.<br />
여기에서 **상호작용**이란, **컴퓨팅 장치의 입력과 출력**을 의미합니다.<br />

그렇다면 입출력이 저수준 계층에서 어떻게 구현되는지 알아봅시다.<br />

<br />

## 6.1 CPU는 어떻게 입출력 작업을 처리할까?

사용자 관점에서 외부에 노출된 장치를 통해 컴퓨터를 사용할 수 있습니다.

- 키보드의 키를 눌러 컴퓨터에 정보를 입력
- 마우스로 화살표를 움직여 컴퓨터에게 명령
- 대화형 인터페이스 정보를 표시하도록 화면을 최적화

프로그래머로서 이런 장치들을 어떻게 이해해야 할까요?

<br />

CPU 내부에는 레지스터가 있듯, 장치에도 자체적인 **장치 레지스터**가 있습니다.

> [!NOTE] 장치 레지스터 (device register)
> 장치와 관련된 일부 정보를 저장합니다.<br />
>
> 1. 데이터를 저장: 키보드의 키를 누른 경우 해당 정보를 레지스터에 저장
> 2. 제어 정보와 상태정보 저장: 레지스터를 읽고 쓰는 작업을 이용

<br />

프로그래머 관점에서 장치란, 저수준 계층의 레지스터를 한 데에 묶은 것에 불과 합니다. 장치에서 생성된 데이터를 얻고, 장치를 제어하는 것은 이 장치 레지스터를 읽고 쓰는 것으로 해결할 수 있습니다.

**장치 레지스터를 읽고 쓰는 작업 역시 기계 명령어롤 통해 이루어집니다.**

<br />

### 6.1.1, 6.1.2

CPU의 입출력 작업 처리 방법에는 두 가지가 있습니다.

1. 입출력 기계 명령어를 사용하는 방법
2. 메모리 사상 입출력 방법

<br />

#### (1) 입출력 기계 명령어 사용 (I/O instruction)

CPU의 특정 기계 명령어가 장치 레지스터를 읽고 쓰도록 설계할 수 있습니다. <br />
이러한 특정 기계 명령어를 **입출력 명령어**(input and output instruction)라 합니다.

- x86 구조에서, `IN` `OUT` 과 같은 입출력 전용 명령어를 사용하여 입출력 장치와 데이터를 주고 받습니다.
- 입출력용 별도 명령어가 필요합니다.
- 입출력 장치들은 별도의 주소공간(I/O 주소공간)으로 구분됩니다.
- CPU는 메모리 접근과 입출력 접근을 명확히 구분하여 처리합니다.
- 메모리 주소 공간과 별도로 장치마다 고유한 주소(I/O 포트)를 부여하고 입출력 명령어에 장치 주소를 지정합니다.

<br />

> 장점<br />
>
> - 입출력 주소를 별도로 관리하므로 메모리 주소를 절약할 수 있습니다.
> - 메모리와 I/O가 물리적으로 충돌할 일이 없습니다.

> 단점<br />
>
> - CPU가 입출력 전용 명령어를 추가로 알아야 하므로 설계가 복잡해집니다.
> - 프로그래머는 메모리 접근과 다른 방식으로 이를 다뤄야 합니다.

<br />

#### (2) 메모리 사상 입출력 (Memory-mapped I/O)

주소 공간의 일부를 장치에 할당하여 메모리를 읽고 쓰는 것 처럼 장치를 제어하는 방식입니다.

- 입출력 장치의 제어 레지스터나 데이터 버퍼를 메모리 주소 공간에 포함시킵니다.
- 메모리처럼 읽고 쓸 수 있습니다.
- 일반 메모리 명령어로 장치에 접근할 수 있습니다.
- RISC계열의 CPU(ARM, MIPS)에서 사용됩니다.

<br />

> 장점<br />
>
> - CPU는 추가 명령어를 배울 필요 없이 메모리 접근 방식 그대로 사용 가능합니다.
> - 별도의 I/O 명령어가 필요하지 않아 설계가 단순합니다.
> - 레지스터 기반 접근, 메모리 연산 최적화 등이 가능합니다.

> 단점<br />
>
> - 메모리 주소 공간의 일부를 장치로 할당하므로 주소 공간이 줄어듭니다.
> - 메모리와 I/O 장치가 주소공간에서 충돌하지 않도록 주의해야 합니다.

<br />

### 6.1.3

키보드의 데이터를 어떻게 읽는지 알았습니다.<br />
그렇다면 언제 이 데이터를 읽어와야 하는걸까요?<br />
CPU는 특정한 방법을 사용하여 장치의 작업 상태를 얻어야 합니다.<br />
키보드 키가 들어오고 있는지, 마우스의 데이터가 들어오고 있는지 등이요.<br />
이는 **장치 상태 레지스터**의 역할입니다.

<br />

### 6.1.4 폴링(polling)

장치 상태 레지스터를 지속적으로 읽는 작업입니다.

```
START
  Load R1 0xFE00 //상태레지스터 읽기
  BLZ START //키보드 상태 0(입력이 없음)이면 START로 점프 (loop구조)
  Load R0 0xFE01 //키보드 상태1(입력 있음)이면 키보드 데이터 R0에 저장
  BL OTHER_TASK //다른 작업으로 점프
```

사용자가 키를 누르지 않는다면 CPU는 불필요한 순환을 하며 대기하게 됩니다.<br />
이는 동기식 설게방식입니다. 이를 개선하기 위해서 동기식 방법을 비동기식으로 변경하면 됩니다.<br />

<br />

### 6.1.5, 6.1.6 인터럽트 구동식 입출력

**우선순위가 중요합니다.**<br />
CPU가 특정 프로세스를 실행하고 있을 때 새로운 이벤트가 발생하면,<br />
**인텉럽트 신호**를 보낸 후, 실행 중인 현재 작업과 인터럽트 요청 간의 작업 **우선순위를 판단**합니다.<br />
인터럽트가 높다면 현재 작업 실행을 일시 중지하고 **실행 상태를 저장**한 후 **인터럽트를 처리**합니다.<br />
인터럽트 처리를 끝낸 후엔 **이전 작업 실행 상태를 복원**하고 다시 현재 작업으로 돌아와 마저 실행하게 됩니다.<br />

프로그램은 언제든지 장치에 의해 실행이 중단될 수 있습니다.<br />
인터럽트 처리와 반환 작동 방식은 프로그램이 마치 중단없이 실행되고 있는 것 처럼 느끼게 합니다.<br />

이처럼 동기 기반의 폴링에서 비동기 인터럽트 구동식 입출력(interrupt driven input and output)으로 변경하여 불필요한 루프를 개선하였습니다.<br />

1. CPU는 인터럽트 신호가 오는 것을 어떻게 감지할까요?
2. 중단된 프로그램의 실행상태를 저장하고 복원하는 방법은 무엇일까요?

<br />

### 6.1.7 인터럽트 신호를 감지하기

CPU가 기계 명령어를 실행하는 과정(명령어 인출, 명령어 해독, 실행, 다시 쓰기)에 하드웨어의 인터럽트 신호 감지 단계를 추가해야합니다.<br />

신호가 감지되는 것은 하나의 장치에서 CPU 처리가 필요한 이벤트가 나타났음을 의미합니다.<br />
이 이벤트 처리여부를 결정해야 합니다.<br />
인터럽트 처리시엔 중단된 작업 상태를 보존해야 합니다.<br />
CPU는 인터럽트 처리 함수의 시작 위치로 점프, 인터럽트 처리 함수의 명령어를 실행한 후 다시 원래 자리로 점프하여 중단된 작업을 실행합니다.<br />

<br />

### 6.1.8 인터럽트 처리와 함수 호출의 차이

사용자 상태의 함수 호출만 고려 했을 때, 둘 다 점프와 반환을 포함하고 있습니다. 이때 함수 호출 전에는 반환주소, 일부 범용 레지스터의 값, 매개변수 등의 정보를 저장합니다.<br />

하지만 인터럽트 처리는 이보다 많은 정보를 저장해야 합니다.<br />
함수 호출은 단일 스레드 내부에서 발생하고 동일한 실행 흐름내에 존재하지만,<br />
인터럽트 처리점프는 서로 다른 두 실행흐름을 포함하고 저장해야 할 정보가 이보다 훨씬 많기 때문입니다.

<br />

### 6.1.9 중단된 프로그램의 실행 상태 저장과 복원

상태가 먼저 저장될수록 상태 복원은 더 나중에 됩니다.<br />
이는 **스택**자료구조를 사용하면 구현할 수 있습니다.<br />
따라서 **프로그램 실행 상태를 저장하는 전용 스택**을 만들어, 반드시 **커널**에 위치시켜야 합니다.<br />
CPU가 커널상태에 진입했을 때에만 이 스택을 사용할 수 있도록 하기 위함입니다.

**인터럽트 처리 프로그램의 점프와 반환 **

- 프로그램이 인터럽트를 감지하면 커널상태에 진입합니다.
- 기존 프로세스의 다음 기계 명령어 주소와 기존 프로세스의 상태를 커널 스택에 push합니다.
- 인터럽트 처리 후 중단된 프로그램으로 다시 점프해서 돌아가야 합니다.
- 커널 스택에서 pop을 실행, PC레지스터에 상응하는 상태레지스터 값을 복원합니다. 다음 기계 명령어 주소를 실행합니다.
