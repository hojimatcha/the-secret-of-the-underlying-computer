## 6.5 mmap: 메모리 읽기와 쓰기 방식으로 파일 처리하기

높은 동시성을 유지하는 입출력 방식에는 두가지가 있습니다.<br />
바로 입출력 다중화와 `mmap` 입출력 기술입니다.<br />
여기에서는 `mmap` 입출력 방식에 대해 알아봅니다.<br />

`mmap`방식에서는 메모리를 읽고 쓰는 것처럼 파일을 읽고 쓴다고 생각합니다.<br />

```c
char buf[1024];

int fd = open("/filepath/abc.txt");
//이 파일을 읽을테니 모든 정보를 준비하고 접근할 수 있는 번호(파일 서술자)를 주세요

read(fd, buf, 1024);
//buf 를 이용한 작업
```

이렇게 파일을 사용하는 작업은 메모리를 사용하는 작업보다 훨씬 더 복잡합니다.<br />

> [!NOTE] 파일 사용이 메모리 사용보다 복잡한 이유
>
> 1. 주소 지정 방법이 다릅니다. 메모리는 바이트(byte)단위로 주소를 지정하는 반면, 디스크는 조각(block) 밀도에 따라 주소를 지정하기 때문에 차이가 있습니다.
> 2. CPU와 디스크 같은 외부장치 간의 속도차이가 더 심합니다. 따라서 디스크의 파일은 메모리에 먼저 저장한 후 메모리에서 바이트 단위로 파일 내용을 처리합니다.

직접 메모리를 사용하는 것은 매우 간단하고 편리합니다. 디스크의 파일을 메모리를 읽고 쓰는 것처럼 할 수 있는 기술이 `mmap` 입출력 기술입니다.

### 6.5.1 파일과 가상 메모리

운영체제가 사용자 상태일 때, 프로그래머 입장에서 메모리는 하나의 연속된 공간처럼 보입니다.<br />
파일 사용자 입장에서 디스크에 저장된 파일도 마찬가지 입니다. 그렇다면 두 공간을 어떻게 연결지을 수 있을까요?<br />

**가상메모리**를 통해 두 공간을 연결 지을 수 있습니다.

> [!NOTE] 가상 메모리
> 가상 메모리의 목적: 모든 프로세스가 각자 독점적으로 메모리를 소유하고 있다고 생각하게 하는 것<br />
> 기계 명령어는 가상 주소를 전달하지만, 가상 주소는 메모리에 도달하기 전 실제 물리 주소로 변환<br />

파일 역시 연속된 디스크 공간에 저장되어 있다고 생각할 수 있으므로 이 공간을 프로세스 주소 공간에 사상할 수 있습니다.<br />
특정 범위에 있는 주소 공간의 메모리를 읽거나 쓸 때 실제로는 디스크 파일을 사용하는 것이 됩니다.<br />
이는 운영체제를 통해 가능해집니다.

### 6.5.2 마술사 운영체제

- 읽기 작업: 파일이 아직 메모리에 적재되지 않은 상태 > 페이지 누락(`page fault`) 인터럽트 > CPU가 OS의 인터럽트 처리함수를 실행 > 실제 디스크 입출력 요청 시작 > 파일을 메모리로 읽고 가상 메모리와 실제 메모리 사이의 연결이 수립 > 직접 디스크 내용을 사용할 수 있게 됨
- 쓰기 작업: 응용프로그램이 이 메모리 조각을 직접 수정할 수 있고 운영체제는 디스크에 해당 내용을 다시 기록

`mmap`을 사용하더라도 실제 디스크를 읽고 써야 하지만 이는 운영체제가 진행합니다.<br />
가상 메모리를 경유하므로 사용자는 이 사실을 신경쓰지 않아도 됩니다.<br />
그렇지만 기존에 사용하던 `read/write`와 어떤 차이가 있는걸까요? `mmap`이 가지는 이점은 무엇일까요?

### 6.5.3 mmap 대 전통적인 read/write 함수

`read/write` 와 같은 입출력 함수는 저수준 계층의 시스템 호출을 사용합니다.<br />
따라서 데이터를 운영체제의 커널 상태에서 사용자 상태로 복사하는 과정을 거치게 됩니다.<br />
`mmap`에서는 이런 문제가 없습니다. 디스크의 파일을 읽고 쓸 때 시스템 호출과 데이터 복사의 부담이 없기 때문입니다.

하지만 항상 `mmap`이 `read/write`보다 뛰어난 것은 아닙니다.

> [!NOTE] mmap 처리 시 알아야 하는 것은
> 커널은 프로세스 주소 공간과 파일의 사상 관계를 유지하기 위해 특정 데이터 구조를 사용해야 하므로 성능에 부담을 가져 올 수 있습니다.<br />
> 페이지 누락 문제로 인한 인터럽트는 반드시 필요하지만 이 역시 부담이 있는 작업이며 커널마다 구현방식이 다릅니다.<br />
> 따라서 구체적인 상황을 보고 `read/write` 의 시스템 호출 및 메모리 복사에서 오는 성능 부담과 `mmap` 의 데이터 구조 사용 및 인터럽트 처리로 인한 성능 부담을 비교하여 사용해야 합니다.

### 6.5.4 큰 파일 처리

`mmap`은 운영 체제의 가상 메모리와 밀접하게 관련이 있어 큰 파일을 다룰 때 이 장점이 크게 발휘됩니다.<br />
여기서 큰 파일이란, 물리 메모리 용량을 초과할 정도의 파일을 의미합니다.<br />

큰 파일을 다룰 때에 전통적인 `read/write`의 문제는 아래와 같습니다.

1. 파일을 조금씩 나누어 메모리에 적재해야 합니다.(화면에 보이는 부분만 메모리에 적재하는 방식)
2. 파일 일부분에 대한 처리가 끝나면 다음 부분에 대한 처리를 해야 합니다.
3. 너무 많은 메모리를 요청하면 메모리 부족 강제 종료가 발생합니다.
4. 전체 파일에 임의로 접근해야 하는 경우 문제가 복잡해집니다.

`mmap`을 사용하면 얻는 이점은 아래와 같습니다.

1. 프로세스 주소 공간이 충분하다면 큰 파일 전체를 프로세스 주소 공간에 직접 사상 가능
2. 파일 크기가 실제 물리 메모리의 크기보다 크더라도 아무 문제 없습니다.

- 매개변수 `MAP-SHARED`: 사상된 영역의 변경 내용은 디스크 파일에 직접 기록
- 매개변수 `MAP-PRIVATE`: 시스템이 실제로 메모리를 할당하므로 물리 메모리의 크기에 교환 영역의 크기를 더한 크기가 기준 > 사용할 파일의 크기는 이 두 영역의 크기를 넘을 수 없음

`mmap`을 사용할 때 주의할 점

1. 32비트 시스템은 프로세스의 주소공간이 4GB이며 그 중 일부는 OS를 위해 예약되어 있습니다.
2. 처리할 파일이 나머지 사용자 영역의 주소 공간보다 크면, 파일을 사상할 연속된 주소 공간이 부족하므로 `mmap`호출을 실패할 수 있습니다.

### 6.5.5 동적 링크 라이브러리와 공유 메모리

많은 프로세스가 하나의 파일을 참조하며 읽기 전용 방식으로 참조하는 경우가 있을까요?<br />
이것은 바로 **동적 링크 라이브러리**에 해당합니다.<br />

정적 링크는 라이브러리 내용을 모두 실행 파일에 복사합니다.<br />
반면 동적 링크 라이브러리는 하나의 라이브러리 코드를 사용하는 프로세스가 모두 동일하게 참조합니다.<br />

이 동적 링크 라이브러리와 `mmap`사이에는 어떤 관계가 있을까요?<br />
많은 프로세스가 동일한 동적 링크 라이브러리에 의존하므로 `mmap`으로 해당 라이브러리를 사용하는 모든 프로세스의 주소 공간에 직접 사상할 수 있습니다.<br />
