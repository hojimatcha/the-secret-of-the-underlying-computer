# 디스크가 입출력을 처리할 때 CPU가 하는 일은 무엇일까?

최신 컴퓨터 시스템의 경우, 사실 디스크가 입출력을 처리할 때 CPU 개입이 필요하지 않다.
디스크가 입출력 요청을 처리하는 동안 운영 체제는 CPU가 다른 작업을 수행하도록 스케줄링한다.

디스크가 입출력 요청을 처리하는 전체 과정에서 왜 CPU 개입이 필요하지 않을까?

장치 제어기, 직접 메모리 접근, 인터럽트의 관계를 이해해보자.

<br />
<br />

## 1) 장치 제어기

디스크와 같은 입출력 장치는 기계 부분과 전자 부분으로 나눌 수 있다.

헤드, 실린더 등으로 볼 수 있는 입출력 요청이 들어왔을 때<br />
읽어야 하는 데이터가 헤드가 위치한 트랙에 없을 가능성이 있는데 이때 헤드가<br />
특정 트랙으로 이동해야 하는데 이 과정을 탐색이라고 한다.

해당 작업은 매우 시간을 많이 소모하는 작업인데<br />
CPU 속도와 비교할 때 기계 장치 작업이기 때문에 극도로 느리기 때문이다.

<br />

### 장치 제어기?

전자 부분은 전자 부품으로 구성되어 있으며 이를 **장치 제어기**라고 한다.

전자 부분은 마이크로 컴퓨터 시스템으로 발전해 자체적인 프로세서와 펌웨어를 갖추고 있고,<br />
장치 드라이버에서 명령을 받아 외부 장치를 제어하는 하드웨어에 해당한다.

장치 제어기는 운영 체제에 해당하는 장치 드라이버와 외부 장치를 연결하는 다리에 해당하며,<br />
점점 더 복잡해지는 목적 중 하나가 CPU를 해방시키는 것이다.

<br />
<br />

## 2) CPU가 직접 데이터를 복사해야 할까?

장치 제어기는 이제 어느 정도의 독립성과 자율성을 가지고 명령을 받은 후<br />
자체적으로 작업을 처리할 수 있다.

CPU 입장에서 데이터를 직접 복사하는 것은<br />
계산 리소스를 극도로 낭비하는 일이기 때문에 CPU 개입이 없는 상황에서<br />
직접 장치와 메모리 사이에 데이터를 전송할 수 있는 하나의 작동 방식을 설계 했는데

이 작동 방식이 바로 **직접 메모리 접근(DMA)**이다.

<br />
<br />

## 3) 직접 메모리 접근

메모리와 외부 장치 사이에서 데이터를 이동시키는 역할을 하는 것이 바로 직접 메모리 접근이다.

CPU가 직접 데이터를 복사할 필요가 없지만 CPU는 반드시 어떻게 데이터를 복사할지<br />
알려 주는 명령어를 DMA에 전달해야 한다.

DMA는 자신의 작업 목표를 명확히 하고 버스 중재,<br />
다시 말해 버스의 사용 권한을 요청한 후 이어서 장치를 작동시킨다.

실제로 DMA는 원래 CPU가 하는 작업 일부를 대신하나,
DMA가 CPU를 해방시키며 또 다른 문제가 발생한다.

> 가상 메모리와 캐시를 지원하는 시스템에서 문제가 발생하는데, <br />
> 이때 한 가지 해결책으로 운영 체제가 DMA에 필요한 가상 주소와 물리 메모리 주소 사이의 <br />
> 사상 정보를 제공해 DMA가 가상 주소를 기반으로 직접 데이터를 전송할 수 있게 했다.

### 또 다른 문제는 없었을까?

캐시가 갱신되지 않는 문제가 있을 수 있는데 이 문제의 해결 방법 중 하나로
상응하는 캐시의 데이터를 즉시 메모리에 갱신하여 일관성 문제가 나타나지 않도록 했다.

그렇다면 CPU는 데이터 전송이 완료되었는지 어떻게 알 수 있을까?

> 인터럽트 작동 방식을 이용해 CPU에게 알려주면 된다.

<br />
<br />

## 4 - 5) 전 과정 처리 / 프로그래머에게 시사하는 것

1. CPU로 실행되는 스레드 1이 시스템 호출로 입출력 요청을 시작하면,
   운영 체제는 스레드 1의 실행을 일시 중지하고 CPU를 스레드 2에 할당하고
   스레드 2가 실행되기 시작한다.
2. 이때 디스크가 동작해 데이터 준비가 완료되면
   인터럽트 작동 방식을 이용해 CPU에서 데이터를 전송한다.
3. 데이터 전송이 완료되면, 인터럽트 작동 방식을 이용해 CPU에게 알리고,
   CPU는 스레드 2의 실행을 일시 중지하고 인터럽트를 처리한다.
4. 운영 체제는 스레드 1이 요청한 입출력 작업이 처리된 것을 확인했기 때문에
   CPU를 다시 스레드 1에 할당하기로 결정한다.
5. 결국 스레드 1이 마지막으로 중단되었던 위치부터 계속 실행된다.

> 디스크가 입출력 요청을 처리할 때 CPU가 그 자리에서 기다리지 않고,<br />
> 운영 체제의 스케줄링에 따라 스레드 2를 실행했다는 것이 핵심이다.

소프트웨어든 하드웨어든 간에 높은 효율성을 이끌어 내는 비결 중 하나는<br />
지금까지 여러 번 확인한 것 처럼 비동기이다. <br />
다른 말로는 "무의존성" 또는 "분리"가 이에 해당한다.<br />

<br />
<br />
