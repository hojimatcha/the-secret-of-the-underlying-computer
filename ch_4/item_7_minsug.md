# 4.7 CPU 진화론(중): 축소 명령어 집합의 탄생

1970년대만 하더라도 메모리 1MB의 가격이 5000달러에 육박했지만 1990년대에 이르러서는 6달러까지 떨어졌습니다.
그리고 컴파일 기술이 진보함에 따라 고급 언어가 더 많이 보급되었습니다.

이 두 가지 흐름이 어떤 변화를 불러왔을까요?

## 4.7.1 복잡함을 단순함으로

80-20 법칙을 아시나요? 이는 CPU에서도 예외는 아니었는데요. CPU 또한 약 80%의 시간 동안 명령어 집합의 기계 명령어 중 20%을 실행했습니다. 다시 말해서 효율성이 매우 떨어진다는 의미지요.

> 80-20 법칙이란
> 상위 20%가 전체 생산의 80%를 맡는다는 원칙입니다.

이를 해결하기 위해 마이크로코드를 제거해서 프로그램을 더 빠르게 실행되게했습니다.

## 자바스크립트로 바라본 복잡 명령어와 축소 명령어

CPU에는 명령어 세트라는 것이 있습니다. 이것은 우리가 자바스크립트에서 사용하는 함수나 문법처럼, CPU가 이해하고 실행할 수 있는 "기본 동작들"을 의미합니다. 이 명령어 세트를 설계하는 방식에 따라 두 가지로 나뉘는데, 그것이 바로 **복잡 명령어 집합**과 **축소 명령어 집합**입니다.

먼저 복잡 명령어 집합는 "복잡한 명령어 방식"입니다. 이것은 자바스크립트에서 한 줄의 코드로 여러 가지 일을 한꺼번에 처리하는 것과 비슷합니다. 예를 들어 user.saveToDatabase() 같은 코드는 내부적으로 여러 작업이 함께 실행되는데, 복잡 명령어 집합 명령어 하나도 이와 비슷하게 여러 가지 작업을 동시에 처리합니다. 이 방식은 코드(명령어)를 짧게 작성할 수 있다는 장점이 있지만, CPU가 그 명령어를 해석하고 실행하는 데 시간이 더 걸릴 수 있습니다. 내부적으로 "무슨 일을 해야 하지?" 하고 더 많은 분석이 필요하기 때문입니다.

반면에 축소 명령어 집합 "간단한 명령어 방식"입니다. 이것은 자바스크립트에서 동작을 명확하게 분리해서 작성하는 것과 비슷합니다. 한 줄에 하나의 명확한 작업만 수행하도록 작성합니다. 축소 명령어 집합 방식의 명령어도 이와 마찬가지로, 각 명령어가 단순하고 구조가 일정합니다. 이 덕분에 CPU는 명령어를 빠르게 해석하고 실행할 수 있으며, 파이프라이닝이나 병렬 처리 같은 최적화도 용이합니다. 하지만 복잡한 작업을 수행할 때는 여러 개의 명령어로 나누어야 하므로 코드가 길어지고, 메모리를 더 많이 사용할 수 있습니다.

## 복잡 명령어를 축소 명령어로 대체할 수 없는 이유

1. 기존 생태계와의 호환성 문제
   복잡 명령어 구조, 특히 x86 아키텍처는 수십 년간 사용되어 온 표준입니다. 이 위에서 돌아가는 운영체제, 컴파일러, 소프트웨어, 드라이버 등 수많은 소프트웨어들이 이미 만들어져 있습니다. 이를 모두 축소 명령어 구조에 맞게 다시 짜야 한다면, 엄청난 비용과 시간이 들게 됩니다.

자바스크립트로 비유하자면, 어떤 회사에서 jQuery 기반의 웹사이트를 운영하고 있는데, 갑자기 이걸 모두 React로 바꾸자고 하면 기존 코드가 안 돌아가거나 문제가 생길 수 있겠죠? 마찬가지로, 복잡 명령어에서 축소 명령어로 옮기면 호환성 문제가 생깁니다.

2. 하드웨어 수준에서의 차이
   복잡 명령어 명령어는 복잡한 기능을 하나의 명령으로 처리할 수 있도록 설계되어 있습니다. 이걸 축소 명령어로 바꾸려면, 복잡한 명령어 하나를 여러 개의 단순한 명령어로 쪼개야 합니다. 이 작업은 단순히 명령어를 나누는 수준이 아니라, 하드웨어 구조 자체를 바꿔야 할 수도 있습니다.

예를 들어, 복잡 명령어는 메모리에서 직접 값을 꺼내 연산을 하지만, 축소 명령어는 반드시 레지스터에 먼저 값을 로드한 후 계산해야 하는 식의 차이가 있습니다. 즉, 단순한 코드 변경이 아니라 CPU 내부 구조까지 바뀌어야 하므로 대체가 어렵습니다.

3. 성능과 최적화 이슈
   복잡한 명령어는 상황에 따라 실제로 더 효율적일 수 있습니다. 예를 들어, 어떤 연산이 반복되거나 데이터 접근이 많을 때는 복잡 명령어 명령어 하나로 더 많은 일을 처리할 수 있어 성능이 유리할 수도 있습니다. 반면 축소 명령어는 단순하지만 많은 명령어를 실행해야 하므로 오히려 오버헤드가 생길 수도 있습니다.

자바스크립트로 비유하면, arr.map(fn).filter(fn2).reduce(fn3) 같은 고차 함수 체이닝을 한 번에 처리하는 내부 최적화 로직을 생각할 수 있습니다. 이걸 for문으로 다 나눠서 쓰면 더 명확하긴 하지만 성능이 떨어질 수도 있겠죠?

4. 특정 용도에 따라 적합한 구조가 다르기 때문
   모든 상황에서 축소 명령어가 더 좋은 것은 아닙니다. 서버나 데스크톱 컴퓨터처럼 복잡하고 다양한 명령어를 자주 사용하는 환경에서는 복잡 명령어가 여전히 강력할 수 있습니다. 반대로 모바일 기기나 임베디드 시스템처럼 전력 효율이 중요한 환경에서는 축소 명령어가 더 적합합니다.

즉, 용도에 따라 적절한 선택이 필요한 것이지, 복잡 명령어를 완전히 축소 명령어로 대체할 수는 없는 구조입니다.
