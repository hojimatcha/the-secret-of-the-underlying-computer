## 4.4 CPU가 if문을 만났을 때

예시 코드를 살펴보겠습니다.

```c
//const: 상수 선언
//unsigned: 양의 정수
const unsigned arraySize = 10000;

//int data[100]
//int(4byte 크기) 정수형 데이터
//data 라는 식별자를 갖는 정수 배열
//data 라는 배열은 크기가 10000
int data[arraySize];

//long long(8byte 크기의 정수형) 데이터 sum
long long sum = 0;

for (unsigned i = 0; i < 100000; ++i)
{
  //아래의 for문을 100000번 연산
  for (unsigned c = 0; c < arraySize; ++c) {
    if (data[c] >= 128) //배열을 순회하며 배열에 저장된 수가 128 이상이면 아래를 실행
    {
      sum += data[c];
    }
  }
}
```

```
[연산 결과]
sum은 크기가 10,000 인 data 배열 중 128 이상인 수를 모두 더한 값 * 100,000
```

- 배열 요소가 정렬된 상태라면 임의로 배치 된 상태에 비해 실행 시간이 매우 짧아집니다.
- 리눅스의 perf 도구를 사용하여, 프로그램 실행 상태에 대한 초기 단계 분석을 볼 수 있습니다.
- 정렬 유무에 따라 `branch-misses` 항목에서 큰 차이가 납니다. 이는 분기 예측 실패율을 나타냅니다.

그렇다면 분기 예측이 무엇일까요? 이를 알기 위해서 파이프라인 기술에 대해 알아봅시다.

### 4.4.1 파이프라인 기술의 탄생

저자는 공장의 파이프 라인을 예시를 들어줍니다. 공장의 생산성을 높이기 위해서 하나의 팀이 모든 라인을 관리하는 것이 아닌, 각 라인마다 팀을 세우는 방식을 통해 생산성 효율을 높이는 것입니다. <br>

- 자동차 하나당 4개의 라인, 각 라인은 20분씩 소요
- 자동차 1대 생산 시 80분 소요
- 하나의 팀이 모든 라인을 관할 하면 80분에 1대 생산
- 각 라인에 팀을 배치하여 관할 하면 첫 80분에 1대가 나오지만, 다음 차 부터는 20분마다 1대씩 생산

즉 라인마다 팀을 세우는 작업이 전체 생산 시간을 줄이는 것이 아니라 공장 처리 능력을 늘리는 것 > 생산 효율성 증대

이러한 방식을 파이프 라인 기술이라고 소개합니다. 이를 어떻게 프로그래밍에 적용했을까요?

### 4.4.2 CPU: 메가팩토리와 파이프라인

CPU를 하나의 메가팩토리(mega factory, 엄청 큰 공장)로 봅니다.<br>
차량 생산 대신 기계 명령어를 실행합니다.<br>
<br>
하나의 기계 명령어를 처리하는 과정

1. 명령어 인출(IF, instruction fetch)
2. 명령어 해독(ID, instruction decode)
3. 실행(execute)
4. 다시쓰기(writeback)

각 단계는 별도의 하드웨어로 처리하며, 실제 CPU 내부에서는 기계 명령어 하나를 수십 단계로 분해하여 실행할 수도 있으므로 초당 수십억 개의 명령어를 처리할 수 있는 능력을 갖추고 있습니다.

### 4.4.3 if 가 파이프 라인을 만나면

프로그래머가 작성한 if 문은 컴파일러가 조건부 점프 명령어로 변환합니다.<br>
이 조건부 점프 명령어는 분기 역할을 합니다.<br>
조건부 점프 명령어를 모두 실행하기 전까지는 **'어디로'** 점프해야 할 지 알 수 없습니다.<br>
하지만 조건부 점프 명령어 실행을 완료하기 전에 다음 명령어(후속 명령어)가 파이프 라인에 들어가 있어야 합니다.<br>
그래야 '빈 공간' 없이 프로세서의 리소스를 완전하게 사용할 수 있기 때문입니다.<br>
<br>
그렇다면 분기 점프 명령어 실행이 끝나기 전, 어떻게 후속 명령어를 미리 결정할 수 있을까요?<br>

바로 **예측**을 통해서 후속 명령어를 결정합니다.

### 4.4.4 분기 예측: 가능한 한 CPU가 올바르게 추측하도록

CPU는 데이터를 기반으로 어디로 분기할 지 '추측'하며 이를 분기 예측이라 합니다.<br>
추측이 맞다면 CPU의 파이프라인은 계속해서 다음 작업을 실행하고,<br>
추측이 틀렸다면, 이미 실행 중이던 잘못된 분기 명령어를 전부 무효화합니다.<br>
이로써 CPU의 성능 손실이 발생하게 됩니다.<br>
<br>
배열의 정렬 유무는 분기 예측에 어떤 영향을 줄까요?
배열이 정렬된 경우

- 배열이 정렬되어 있는 경우
  - if 조건의 결과가 매우 규칙적
  - CPU의 예측 성공률이 높아집니다
- 배열이 정렬되지 않은 경우
  - if 조건의 결과가 뒤죽박죽
  - 무작위 이벤트, 성능 손실

따라서 높은 성능을 요구하는 코드와 if문을 작성할 때 CPU가 높은 확률로 추측할 수 있도록 코드를 작성해야 합니다.<br>

이것이 프로그래밍 언어에 likely/unlikely 매크로가 있는 이유 입니다.<br>
이 매크로를 이용하여 컴파일러에 가능성이 더 높은 분기를 알려줄 수 있습니다.<br>

> **likely, unlikely 매크로란?** <br>
> if 문과 같은 조건 분기에서 어떤 조건이 자주 발생(true)하는지 드물게 발생하는지(false) 컴파일러에게 안내해줍니다.
>
> ```cpp
> // GCC, clang 기준 정의
> #define likely(x)   __builtin_expect(!!(x), 1)
> #define unlikely(x) __builtin_expect(!!(x), 0)
> ```
>
> `__builtin_expect(EXP, VALUE)`: EXP가 VALUE일 가능성이 높다고 컴파일러가 판단
>
> `__builtin_expect(x == 0, 1);` x == 0 이 자주 발생할 것이라고 예상
>
> ```cpp
> if (likely(x > 0)) {
>   //이 분기가 자주 실행될 것
> } else {
>  //이 분기는 드물게 실행될 것
> }
> ```
