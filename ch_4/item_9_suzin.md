## 4.9 CPU, 스택과 함수 호출, 시스템 호출, 스레드 전환, 인터럽트 처리 통달하기

- 함수 호출: 코드 재사용성 개선
- 시스템 호출: 운영체제에 요청
- 프로세스 전환/스레드 전환: 다중 작업(multitasking)
- 인터럽트 처리: 운영 체제가 외부 장치를 관리

이 구조는 컴퓨터 시스템의 기반이 됩니다. 이 구조들의 구현에 대해서 알아봅시다.

<br />

### 4.9.1 레지스터

레지스터와 메모리는 둘 다 정보를 저장하는데에 사용되므로 본질적인 차이가 없습니다.<br/>

> **CPU에 레지스터가 필요한 이유?** 속도<br />
>
> CPU가 메모리에 접근하는 속도 x 100 `===` CPU가 레지스터에 접근하는 속도<br />
> 레지스터의 읽기와 쓰기 속도는 메모리에 비해 훨씬 빠르고, 제조 비용은 훨씬 비싸서 용량에 한계가 있습니다.<br />
> 따라서 대부분의 프로세스 실행 정보는 메모리에 저장하고 CPU 사용 시에만 임시로 레지스터에 저장합니다.

더 빠른 실행 속도를 위해 레지스터를 사용합니다.<br />
이제 레지스터의 유형에 대해 알아봅시다.

<br />

### 4.9.2 스택 포인터

> **스택 프레임**<br />
> 함수가 호출될 때 마다 해당 함수의 지역 변수, 매개 변수, 반환 주소 등이 저장되는 메모리 공간

> **스택 포인터**<br />
> 현재 스택의 가장 상단을 가리키는 포인터<br />
> 스택에서 현재 가장 위에 있는 주소로 다음에 데이터가 들어갈 자리를 가리킵니다.

<br />

스택 포인터는 스택의 상단을 가리킵니다.<br />
함수가 호출될 때 마다 스택 프레임이 쌓이고 스택 포인터는 위로 이동합니다.<br />
함수가 종료되면 아래로 내려갑니다.<br />

<br />

### 4.9.3 명령어 주소 레지스터

**명령어 주소 레지스터**는 '지금 어떤 명령어를 실행하는지' 즉 함수의 실행 시간 스택 정보를 갖습니다.<br />

> **명령어 주소 레지스터 동의어**<br />
> PC(program counter), IP(instruction pointer in x86)

컴파일러가 번역한 기계 명령어를 CPU가 실행하기 위해서 명령어 주소 레지스터에 실행할 명령어의 주소를 저장합니다.<br />
일반적으로 명령어는 순차적으로 실행(PC 레지스터 값은 순차적으로 증가)하지만,<br />
분기 점프 및 함수 호출과 반환 등에 의해 명령어 실행 순서는 유동적으로 변경이 가능합니다.<br />
CPU의 PC레지스터를 제어하는 것은 CPU의 실행 흐름을 제어하는 것과 같습니다.

<br />

### 4.9.4 상태 레지스터

> **상태 레지스터 동의어**<br />
> x86구조 | FLAGS 레지스터<br />
> ARM구조 | 응용 프로그램 상태 레지스터

> **상태 레지스터가 저장하는 정보**<br />
> 산술 연산이 포함된 명령어의 자리 올림수(carry)<br />
> 연산 수행 중 발생하는 overflow<br />
> CPU의 모드 정보: 사용자 상태(User Mode) 또는 커널 상태(Kernel Mode)

<br />

### 4.9.5 상황 정보

> **상황정보**란? 프로그램이 실행된 직후부터 현 시점에 레지스터에 저장된 모든 정보

<br />

> **상황 정보로 무엇을 할 수 있을까요?**<br />
> 언제든 프로그램의 실행을 일시 중지할 수 있습니다.<br />
> 반대로 언제든 프로그램의 실행을 재개할 수 있습니다.

<br />

> **상황정보를 저장하고 복원해야 하는 이유는 뭘까요?**<br />
> 만약 CPU가 모든 기계어를 순차적으로 실행한다면, 현재 실행 정보만 알아도 됩니다.<br />
> 하지만 CPU는 **제어 이전과 관련된 일부 기계 명령어**로 인해 엄격한 오름차순으로 기계 명령어를 실행하지 않습니다.<br />

> **엄격한 오름차 순으로 실행되지 않는다?**<br />
> 프로그램에 명시된 순서대로 실행되지 않음을 의미합니다.<br />
> 함수 호출과 반환, 시스템 호출에 의한 CPU모드 변경, 스레드 전환, 인터럽트 처리 등에 의해<br />
> 순서가 유동적일 수 있음을 의미합니다.<br />

이러한 기계 명령어의 실행 흐름은 순차적이죠. 이 흐름 자체를 바꾸는 것은 불가능합니다.<br />
하지만 기계어의 순차적 실행을 **중단**할 수는 있습니다.<br />
따라서, 중단 되기 전 복구를 대비해 CPU는 중단되기 전 상태를 저장해야 합니다.<br />

> **저장해야 하는 상황 정보(Context)**<br />
> 함수 호출<br />
> 시스템 호출<br />
> 스레드 전환<br />
> 인터럽트 처리

위 4가지 상황정보를 어떻게 구현하는지 알아봅시다.<br />
상황정보를 저장하는 방법과 저장 장소를 알아봅시다.<br />
그리고 어떻게 중단된 CPU의 실행을 복원하는지도 알아봅시다.

<br />

### 4.9.6 중첩과 스택

**스택**은 **중첩구조를 처리**하기 위해 탄생했습니다.<br />
소프트웨어로 스택을 구현하기도 하고 하드웨어로 스택을 구현할 수도 있습니다.<br />
상황정보를 저장하기 위해 스택을 어떻게 사용하고 구현했는지 알아봅시다.<br />

### 4.9.7 함수 호출과 실행 시간 스택

> **함수 호출**<br />
> 호출된 함수의 첫번째 기계 명령어로 점프한 후 함수 실행이 완료되면 다시 원래 위치로 점프해야 합니다.<br />

**보존해야 하는 상태 정보 |** 반환 주소와 사용한 레지스터 정보<br />
**복원하기 위해 |** 모든 함수 실행 시, **함수의 실행 정보를 스택 프레임**에 저장

<br />

### 4.9.8 시스템 호출과 커널 상태 스택

스레드를 생성하는 주체는 운영체제입니다.<br />

> `open` 호출 시<br />
> 응용 프로그램은 시스템 호출(system call)을 통해 운영체제에 서비스 요청<br />
> 운영체제가 요청을 처리하는 함수를 호출<br />
> 다른 함수와 마찬가지로 **실행 시간 스택**이 필요<br />
> 운영체제가 시스템 호출을 완료하는 데 필요한 실행스택은 **커널 상태 스택**

<br />

**시스템 호출 과정**

<hr />

**모든 사용자 상태 스레드는 커널 상태에 대응하는 커널 상태 스택**을 갖습니다.<br />

1. 사용자 스레드에서 시스템 호출을 사용하여 운영체제의 서비스를 요청합니다.
2. **시스템 호출은 특정 기계 명령어에 대응**합니다.
3. 해당 기계 명령어에 의해 사용자 상태에서 커널 상태로 전환(CPU의 상태 전환)됩니다.
4. **커널 상태에서 사용자 상태 스레드에 대응하는 커널 상태 스택**를 찾습니다.
5. 이때 **사용자 상태 스레드의 레지스터 정보와 같은 실행 상황 정보**도 **커널 상태 스택**에 저장합니다.
6. 대응 하는 커널 코드를 실행하여 시스템 호출 요청을 처리합니다.
7. 시스템 호출이 완료되면 커널 상태 스택에 저장된 사용자 상태 프로그램의 상황 정보를 통해 CPU상태를 복원합니다.
8. 계속해서 사용자 상태 프로그램을 실행합니다.

<br />

### 4.9.9 인터럽트와 인터럽트 함수 스택

컴퓨터가 프로그램을 수행하는 도중에도 키보드 입력, 마우스의 움직임, 네트워크 수신 등 작업을 처리할 수 있습니다.<br />
이는 모두 **인터럽트 작동 방식**을 통해 처리하는 것입니다.

> **인터럽트?**<br />
> 현재 CPU의 실행 흐름을 끊고 특정 인터럽트 처리 함수로 점프합니다.<br />
> 인터럽트 처리 함수의 실행 완료 시, 원래 위치로 다시 점프합니다.<br />

인터럽트 처리 함수 역시 함수입니다.<br />
실행 시간 스택이 있어야 합니다.<br />
그렇다면 인터럽트 처리 함수의 실행 시간 스택은 어디에 위치할까요?<br />

<br />
<br />

**인터럽트 처리함수의 실행시간 스택 구현**

<hr />

**인터럽트 처리 함수에 자체적인 실행 시간 스택이 없는 경우**<br />
커널 상태 스택을 사용하여 인터럽트 처리<br />

**인터럽트 처리 함수에 자체적인 실행 시간 스택이 있는 경우**<br />
인터럽트 처리 함수 ISR(interrupt service routine) 스택이라는 자체 실행 스택을 사용하여 인터럽트 처리<br />

어떤 스택을 사용하는지 다를 뿐 시스템 호출과 유사하게 동작합니다.<br />
다만 다른점은 아래와 같습니다.

- **시스템 호출**은 **사용자 상태 프로그램**이 직접 실행
- **인터럽트 처리**는 **외부의 장치**에 의해 실행

CPU가 사용자 상태에서 모든 기계 명령어를 실행할 때 마다 인터럽트가 발생할 수 있습니다.<br />

<br />

**인터럽트 처리의 과정**

<hr/>

1. CPU가 사용자 상태에서 커널 상태로 전환
2. 사용자 상태 스레드에서 대응하는 커널 상태 스택을 찾아 커널 상태 스택에 사용자 상태 스레드 실행 상황 정보 저장
3. CPU는 인터럽트 처리 함수의 시작 주소로 점프
4. 커널 상태 스택에서 인터럽트 처리 함수 실행(함수 호출과 반환에 따라 커널 상태 스택의 크기가 증가 및 감소)
5. 인터럽트 처리 함수 실행 완료 후 커널 상태 스택에 저장된 상태 정보에 따라 CPU 복원
6. 다시 사용자 상태로 전환하여 사용자 상태 스레드 계속 실행

<br />

### 4.9.10 스레드 전환과 커널 상태 스택

**인터럽트 시작 과정**

<hr/>

1. 시스템 내부의 타이머가 인터럽트 신호를 발생 시키면, CPU는 인터럽트 신호를 수신하고 현재 스레드를 일시 중지 합니다.
2. 사용자 상태에서 커널 상태로 전환합니다.
3. 커널 내 timer interrupt handler를 실행합니다.

<br />

**타이머 인터럽트 처리 프로그램**<hr/>
타이머 인터럽트 처리 프로그램은 스레드에 할당된 시간 조각이 전부 사용되었는지 확인합니다.
<br />
시간이 남았다면 사용자 상태로 돌아가 계속해서 실행합니다.<br />
시간 조각이 모두 사용되었다면 CPU는 다른 스레드에 할당(스레드 전환)되어야 합니다.<br />

<br />

**스레드 전환 과정**<hr />
스레드 전환 과정은 아래의 두 과정을 포함합니다.<br />

1. **주소 공간의 전환 |**
   서로 다른 프로세스에 속해 있을 수 있고, 서로 다른 프로세스라면 서로 다른 주소공간을 사용하고 있으므로 주소공간을 전환합니다.
2. **CPU 스레드의 전환 |**
   CPU의 스레드를 전환하도록 합니다. 이전 스레드의 CPU 상황 정보를 저장하고 다음 스레드의 CPU 상황 정보를 복원합니다.

<br />

모든 리눅스 스레드에는 각각에 대응하는 `task_struct`라는 프로세스 서술자가 존재합니다.<br />
이 안의 `thread_struct`구조체가 CPU의 상황정보를 저장합니다.<br />

컴퓨터 시스템의 구현은 스택의 구조를 활용한 CPU 상황 정보의 저장과 복원을 통해 이루어집니다.

### 4.10 요약

이 장에서 트랜지스터와 CPU의 기본 동작 원리에 대해 알아보았습니다.<br />
운영 체제와 수치 체계, 스레드, 역사적으로 CPU가 변화해 온 과정, 복잡 명령어 집합과 축소 명령어 집합, 그리고 그 진화 과정에 대해서도 알아보았습니다.<br />
함수 호출, 시스템 호출, 인터럽트 처리, 스레드 전환에서 스택을 활용한 구현에 대해서도 알아보았습니다.<br />
또한 CPU에서 상황 정보를 저장하고 복원하는 과정 없이는 프로그램 실행이 이루어지지 않음을 알 수 있었습니다.<br />
프로그램이 실행 중일 때에도 CPU는 메모리와 계속해서 상호 작용 하며 명령어와 데이터를 읽어 온다는 것을 알 수 있습니다.<br />

그렇다면 CPU와 메모리의 상호작용은 어떻게 이루어질까요?<br />
5장에서 투비컨티뉴....