# 이 작은 장난감을 CPU라고 부른다

현대 컴파일러 같은 도구 덕분에 프로그래머는 인간에 가까운 언어를 이용해 초당 수십억 번에서 수백억 번 연산이 가능한 트랜지스터로 구성된 신기한 장치를 다룰 수 있게 되었다.

CPU 동작 원리를 이해하면 전체 컴퓨터 시스템에 대한 이해가 깊어지기에 더 나은 프로그램을 작성할 수 있는데 이 인간의 만든 정점인 CPU는 도대체 무엇일까?

<br />
<br />

## 1) 위대한 발명

### 트랜지스터(transistor)은 어떤 역할을 할까?

트랜지스터 기능은 단자 한쪽에 전류를 흘리면 나머지 단자 두 개에 전류가 흐르게 할 수도 있고 흐르지 못하게 할 수도 있는데 그 본질은 스위치와 동일하다.

> 프로그래머가 작성한 프로그램이 아무리 복잡해도 소프트웨어가 수행하는 기능은 최종적으로 이 작은 물건의 간단한 계폐 작업으로 완성된다.

<br />
<br />

## 2) 논리곱, 논리합, 논리부정

트랜지스터라는 스위치를 기초로 삼아 블록을 만들 수 있다.

- 스위치 두 개가 동시에 켜질 때만 전류가 흐르고 등이 켜진다.
- 두 스위치 중 하나라도 켜져 있으면 전류가 흐를 수 있고 등이 켜진다.
- 스위치를 닫으면 전류가 흘러 등이 켜지지만, 스위치를 열면 전류가 흐르지 않고 등이 꺼진다.

> 이것이 각각 "논리곱 게이트(AND)", "논리합 게이트(OR)", "논리부정 게이트(NOT)"이다.

<br />
<br />

## 3) 도는 하나를 낳고, 하나는 둘을 낳고, 둘은 셋을 낳으며, 셋은 만물을 낳는다.

충분한 "논리곱 게이트(AND)", "논리합 게이트(OR)", "논리부정 게이트(NOT)"가 있으면 어떤 논리 함수도 구현할 수 있다. 이외에는 어떤 형태의 논리 게이트 회로도 필요하지 않다.

> 컴퓨터가 간단한 "논리곱 게이트(AND)", "논리합 게이트(OR)", "논리부정 게이트(NOT)"로 구성될 수 있다는 것.

<br />
<br />

## 4) 연산 능력은 어디에서 나올까?

모든 것을 얻을 수 있는 기초 원소인 "논리곱 게이트(AND)", "논리합 게이트(OR)", "논리부정 게이트(NOT)"가 등장하고, CPU의 가장 중요한 능력인 연산을 설계해보자.

2진법으로 덧셈을 하면 다음과 같다.

1. 0 + 0의 결과(result)는 0이며, 자리 올림수(carry)도 0
2. 0 + 1의 결과는 1이며, 자리 올림수는 0
3. 1 + 0의 결과는 1이며, 자리 올림수는 0
4. 1 + 1의 결과는 0이며, 자리 올림수는 1

> 먼저 자리 올림수를 보면 두 입력 값 두 개가 모두 1일 때만 1이라는 점에 유의하며, 조합 회로 세 개를 생각해 보면, 이것이 논리곱 게이트라는 것을 알 수 있다.

### 결과(result)를 봐보자

두 입력 값이 서로 다르면 결과가 1이고, 두 입력 값이 서로 같으면 결과가 0이다. 이것을 **배타적 논리합(exclusive OR)**이라고 한다.

배타적 논리합 게이트도 논리곱 게이트, 논리합 게이트, 논리부정 게이트 세 가지만으로 구성할 수 있는데 <u>논리곱 게이트 한 개와 배타적 논리합 게이트 한 개를 조합하면 2진법 덧셈을 구현</u>할 수 있다.

이것이 바로 간단한 가산기(adder)이다. 덧셈 외에도 다른 산술 연산도 설계 가능하다.

### CPU에는 전문적으로 계산을 담당하는 모듈이 있다!

바로 ALU라는 산술 논리 장치(Arithmetic Logic Unit)이다. 간단한 회로보다는 좀 더 복잡하다.

연산 능력은 이렇게 생겼지만 회로는 정보를 기억할 수 있어야하는 문제가 남아있었다.

<br />
<br />

## 5) 신기한 기억 능력

### 회로가 어떻게 정보를 저장할 수 있을까?

부정 논리곱 게이트(NAND gate, Not AND) 두 개를 조합한다.<br />
부정 논리곱 게이트 역시 논리곱 게이트와 논리부정 게이트를 조합한 것이다.

1. 논리곱 연산을 처리한다.
2. 논리부정 연산을 처리한다.
3. 예를 들어 1과 0을 입력했다면 논리곱 연산 결과는 0이된다.
4. 이를 다시 논리부정 연산을 하면 1이 된다.

이 회로의 독특한 점은 부정 논리곱 게이트의 출력이 다른 부정 논리곱 게이트의 입력으로 연결된다는 것이다. S와 R 단자가 1일 때, 회로는 두 가지 상태를 가진다.

- a가 1이면 B = 0, A = 1, b = 0
- a가 0이면 B = 1, A = 0, b = 1

> 이외의 다른 상태는 존재하지 않으며, a의 값이 그대로 출력된다.

S 단자를 0으로 설정하면 R 단자가 1이 유지되며, 회로는 1이 저장된 상태가 된다. 반대로 R 단자를 0으로 설정하면 S 단자가 1이 유지되며, 회로는 0이 저장된 상태가 된다.

즉, 이 회로는 정보를 저장할 수 있는 기능을 갖는다.

하지만 저장하려면 S와 R 단자를 동시에 설정해야 하므로 불편함이 있다. 이를 개선하기 위해 **WE(Write Enable) 단자**를 추가하여 저장 여부를 선택하도록 한다.

> WE 단자를 추가한 회로에서는 D 단자가 0이면 회로에 0이 저장되고, 1이면 1이 저장된다. 이를 통해 1비트를 간단히 저장할 수 있는 회로가 완성된다.

<br />
<br />

## 6) 레지스터와 메모리의 탄생

회로는 1비트를 저장할 수 있다. 더 많은 비트를 저장하면 조합 회로를 쓰면 된다.
이 조합 회로를 레지스터(register)라고 부른다.

- 더 많은 정보를 저장하고 주소 지정 기능을 제공하기 위해 더 복잡한 회로를 계속 구축한다.
- 8비트를 1바이트로 규정한다.
- 각각의 바이트가 자신의 번호를 받는다.
- 이 부여된 번호를 이용해 회로에 저장된 정보를 읽는다.

> 이것이 메모리의 탄생! 레지스터와 메모리 모두 회로와 떨어질 수 없고 전원에 연결되어 있는 한 메모리는 데이터를 저장할 수 있다.(전원이 꺼지면 저장 불가능)

<br />
<br />

## 7) 하드웨어 아니면 소프트웨어? 범용 장치

우리가 논리곱 게이트, 논리합 게이트, 논리부정 게이트를 사용해 모든 논리 함수를 표현할 수 있다고 해도 모든 논리 함수를 논리곱 게이트, 논리합 게이트, 논리부정 게이트를 사용해 구현할 필요가 있을까? 매우 비현실적이다.

> 요리사에 비유한다면 요리사 한 명이 한 가지 요리만 전담하는 것이 비효율적인 것과 같다.

### 모든 연산 논리를 반드시 회로 같은 하드웨어로 구현할 필요는 없다.

하드웨어는 변하지 않지만 소프트웨어는 변할 수 있다. 변하지 않는 하드웨어에 서로 다른 소프트웨어를 제공하면 하드웨어가 완전히 새로운 기능을 구현할 수 있다.

> 다양한 앱을 사용할 때마다 서로 다른 소프트웨어들로 서로 다른 기능을 가질 수 있는데 이것이 바로 컴퓨터를 범용 연산 장치라 하는 이유다.

<br />
<br />

## 8) 하드웨어의 기본 기술: 기계 명령

### CPU는 어떻게 연산을 하고, 어떤 두 숫자를 더할 지 알 수 있을까?

요리사에게 레시피를 제공해 주어야 하는 것처럼 CPU 역시 자신이 이어서 무엇을 해야 하는지 알려주는 "레시피"가 필요하다. 여기서 레시피는 바로 기계 명령어이며, 이 기계 명령어는 조합 회로를 이용해 실행된다.

### 이런 기계 명령어가 많으면 어떻게 할까?

예를 들어 덧셈 연산이 엄청 많다고 하더라도 CPU는 덧셈 연산의 연산 능력만 제공하고, 프로그래머가 피연산자를 제공하면 된다.

> CPU 표현 방식은 명령어 집합을 이용해 구현된다.

<br />
<br />

## 9) 소프트웨어와 하드웨어 간 인터페이스: 명령어 집합

### 명령어 집합(instruction set)?

명령어 집합은 CPU가 실행할 수 있는 명령어와 각 명령어에 필요한 피연산자를 묶은 것이다. 서로 다른 유형의 CPU는 서로 다른 명령어 집합을 가지고 있다.

명령어 집합에서 명령어 한 개가 수행할 수 있는 작업은 매우 간단하다.

메모리에서 숫자를 읽거나 더하거나 비교하는 등의 작업은 기계 명령어로 변환되어 CPU에서 하나씩 실행된다. 복잡한 프로그램도 결국은 단순한 논리 연산의 집합으로 실행되는 것이다.

예를 들어, 16비트 기계 명령어는 처음 4비트가 CPU에 수행할 작업을 알리고, 나머지 비트는 어떻게 동작해야 하는지를 지정한다. 이 명령어에서는 레지스터 R6와 R2를 더한 후 R6에 저장하는 연산을 수행한다.

> 기계 명령어는 단순하지만 이를 직접 프로그래밍하는 것은 어려우므로, 인간이 이해하기 쉬운 고급 프로그래밍 언어가 탄생했다. CPU는 여전히 기계 명령어만 이해할 수 있기 때문에, 컴파일러가 고급 언어를 기계 명령어로 변환하는 역할을 한다.

<br />
<br />

## 10) 회로에는 지휘자가 필요하다

### 각 부분의 회로가 함께 작업할 수 있도록 조정하거나 동기화하려면 어떻게 해야 할까?

교향곡 연주를 성공적으로 하려면 지휘자가 필요한 것처럼 회로에도 지휘자가 필요한데 CPU에서 지휘자 역할을 맡고 있는 것이 클럭 신호이다.

클럭 신호는 지휘봉과 같이 클럭 신호가 전압을 변경할 때마다 전체 회로의 각 레지스터가 갱신된다.

### 클럭 주파수는 무엇을 의미할까?

클럭 주파수는 1초 동안 지휘봉을 몇 번 흔드는가를 의미하고, 클럭 주파수가 높을수록 CPU가 1초에 더 많은 작업을 할 수 있음을 자명한다.

<br />
<br />

## 11) 큰일을 해냈다, CPU가 탄생했다!

산술 논리 장치, 정보를 저장하는 레지스터, 작업을 함께 제어해 주는 클럭 신호를 한데 묶은 것을 일컬어 중앙 처리 장치, CPU 또는 프로세서라 한다.

CPU가 명령어를 실행하는 핵심적인 기능을 하고 있기에 또 중요하고 가장 핵심적인 부분이다.
