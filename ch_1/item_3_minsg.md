# 1.3

라이브러리는 대부분 정적 라이브러리 혹은 동적 라이브러리의 형태로 제공된다.
위 두 단어가 무엇을 의미하는지 그리고 컴파일러와 달리 작동하는 **링커**는 어떤 역할을 하는지 알아보자.

## 1.3.1 링커는 이렇게 일한다.

링커는 컴파일러와 마찬가지로 일반적인 프로그램이다.
컴파일러는 고수준 언어를 저수준 언어로 바꾸는 임무를 수행하는 것으로 잘 알려져있지만 링커는 비교적 잘 알려져 있지 않다.
링커는 여러 개의 개별 객체 파일을 결합하고, 참조된 메모리 주소를 해결하여 하나의 실행 가능한 파일을 생성하는 프로그램이다.
저자는 이러한 링커의 역할을 개별 장을 묶어 책 한 권으로 출판하는 것으로 비유한다.

예를 들어, "CPU에 대한 자세한 설명은 N쪽을 참고하세요"라는 문구가 있을때 컴파일러는 N에 해당하는 메모리 주소를 모르기때문에
N으로 표시해두고 링커가 N을 N에 해당하는 메모리 주소로 대체합니다.

## 1.3.2 심벌 해석: 수요와 공급

심벌은 전역 변수와 함수의 이름을 포함하는 **모든 변수 이름을** 의미한다. 이때 지역 변수는 제외된다.
링커는 심벌 해석 단계에서 심벌이 참조하는 외부 메모리 주소가 존재하는지 그리고 단 하나만 존재하는지 확인한다.
컴파일러가 이를 도와주기도 하는데 컴파일 과정에서 소스 파일마다 외부에서 참조 가능한 심벌이 어떤 것인지 그 정보를 기독한다.
혹은 어떤 외부 심벌을 참조하고 있는지도 기록한다.

그러나, 참조된 변수 정의를 찾는 것은 링커의 몫이다.

## 1.3.3 정적 라이브러리, 동적 라이브러리, 실행 파일

정적 라이브러리는 소스 파일 여러 개를 미리 개별적으로 컴파일하고 링크된 파일을 의미한다.
이떄 즁요한 점은 소스 파일마다 단독으로 컴파일을 한다는 것이다. 그리고 이후 실행할 때는 내 코드만 컴파일하며 정적 라이브러리 코드는
다시 컴파일되지 않고 링크 과정에서 그대로 실행 파일에 복제된다.

정적 라이브러리는 컴파일되지 않기 때문에 실행 속도가 빠르다는 장점이 있지만 코드를 복사한다는 측면에서 메모리를 많이 차지할 수 있다는 단점이 있다.

반면 동적 라이브러리는 이름, 심벌 테이블, 재배치 정보 등 필수 정보면 실행 파일에 포함된다.
모든 코드를 복사하지 않기 때문에 정적 라이브러리에 비해 실행 파일의 크기를 줄일 수 있다는 큰 장점이 있다.

실행 파일에 저장된 동적 라이브러리의 필수 정보는 동적 링크 과정에서 사용된다.

동적 링크는 2 가지 방식이 있다.
첫 번째는 프로그램이 메모리에 적재될 때 동적 링크가 진행되며 두 번쨰는 프로그램 런타임때 진행된다.

## 1.3.4 동적 라이브러리의 장단점

동적 라이브러리의 가장 큰 장점은 의존하는 프로그램의 개수가 얼마가 되었든 상관없이 디스크에는 동적 라이브러리의 복사본이 하나만 저장된다는 점이다.
이렇게 메모리 적재와 디스크 저장에 필요한 리소스를 대폭 절약할 수 있기 때문에 동적 라이브러리를 공유 라이브러리라고도 한다.

이외에도 동적 라이브러리 코드를 수정할 때 다른 코드를 다시 컴파일할 필요가 없다는 점 그리고 플러그인을 손 쉽게 구현할 수 있다는 장점이 있다.

이와 반대로 프로그램이 적재되는 시간 또는 실행 시간에 링크되기 때문에 성능이 떨어진다는 단점이 있다.
