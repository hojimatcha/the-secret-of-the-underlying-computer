# 3.6 고성능 서버의 메모리 풀은 어떻게 구현될까?

C 언어에서 잘 사용되는 malloc은 사실 성능이 뛰어난 함수는 아닙니다. 왜냐하면 범용적인 상황에서 사용될 수 있기 때문이죠.
대신 특정 상황에서 사용할 수 있는 메모리 풀이란 기술은 성능이 최적화되어있어서 malloc에 비해서 시스템 성능에 영향을 미치지 않습니다.

## 3.6.1 메모리 풀 대 범용 메모리 할당자

메모리 풀과 malloc은 크게 두 가지 차이점이 있습니다.
첫 번째는 이 둘이 속한 계층의 위치로 malloc은 표준 라이브러리에 속하지만 메모리 풀은 응용 프로그램에 속합니다.

> C 언어의 표준 라이브러리에 대해 알아보자!
> | 헤더 파일 | 주요 기능 |
> |------------|--------------------------------------------|
> | `<stdlib.h>` | 동적 메모리 할당 (`malloc`, `free` 등), 숫자 변환, 난수 생성 |
> | `<stdio.h>` | 입출력 (`printf`, `scanf`, `fopen` 등) |
> | `<string.h>` | 문자열 처리 (`strlen`, `strcpy`, `strcmp` 등) |
> | `<math.h>` | 수학 함수 (`sqrt`, `pow`, `sin`, `cos` 등) |
> | `<time.h>` | 시간 및 날짜 관련 기능 (`time`, `clock`, `strftime` 등) |

두 번째는 사용 대사에 있습니다. malloc은 거의 대부분의 상항에서 사용가능하지만 메모리 풀은 그렇지 않습니다. 특정 상황에서만 사용이 가능하자민 성능은 malloc에 비해서 더 우수합니다.

다시 말해서 메모리 풀 기술은 보편적이지 않고 특수합니다.

## 3.6.2 메모리 풀 기술의 원리

메모리 풀 기술은 운영 체제와 표준 라이브러리 계층을 거치지 않습니다. 이는 프로세스가 응용 프로그램에 바로 메모리를 할당 및 해제를 요청하기 때문입니다.

방금 전 메모리 풀 기술은 특수하다고 했는데 왜냐하면 특정 사용 패턴에 따라 최적화가 가능하기 때문입니다. 사용자 요청마다 여러 종류의 객체를 생성해야한다면 자체 메모리 풀에 이런 객체를 생성해둠으로써 성능을 최적화할 수 있습니다.

## 3.6.3 초간단 메모리 풀 구현하기

메모리 풀을 구현하기 위해서는 상황의 정의돼야 합니다. 간단한 메모리 풀은 간단한 상황을 해결할 수 있습니다. 예를 들어, 사용자 요청을 처리할 때 한 종류의 객체가 필요하다고 하면 그 객체에 대한 메모리만 다룰 수 있는 메모리 풀을 생성할 수 있습니다.

## 3.6.4 약간 더 복잡한 메모리 풀 구현하기

만약 객체의 크기가 달라서 여러 크기의 메모리를 할당하려면 여유 메모리 조각을 관리해야 합니다. 이때 모든 메모리 조각을 연결 리스트로 연결하고 포인터를 사용해서 여유 메모리 조각의 위치를 기록할 수 있습니다.

메모리 풀에서 한 가지 더 다른 점은 메모리 해제가 요청 처리 완료 후에 한번에 이뤄진다는 점입니다.
