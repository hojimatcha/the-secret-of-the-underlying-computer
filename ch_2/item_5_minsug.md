# 2.5 콜백 함수를 철저하게 이해한다

처음 자바스크립트를 배웠을 때 가장 이해하기 어려운 개념 중 하나가 콜백 함수였습니다.
콜백 함수가 왜 필요한 것인지 어떤 기능하는 것인지 알고싶었지만 그 당시에는 무엇도 쉽지 않았습니다.
시간이 지나면서 개념과 사욥법을 체득했지만 이번 쳅터를 통해서 조금 더 깊이 알아보는 시간이 됐습니다.

## 2.5.1~2 모든 것은 다음 요구에서 시작된다 - 콜백이 필요한 이유

A팀과 B팀이 있습니다. B팀은 모듈화된 함수를 제공하고 A팀은 함수를 호출합니다.
이제 C팀도 B팀의 모듈화된 함수를 사용하고 싶습니다. 그래서 B팀은 함수를 다음과 같이 수정합니다.

```js
function foo() {
  if (teamA) {
    ...
  }

  if (teamB) {
    ...
  }
}
```

지금까지는 별 문제가 없어보이지만 D,E,F,,,Z팀까지 나오면 어떻게 될까요? 마냥 분기처리를 계속해야할까요?
유지보수는요? 커스텀을 계속 요청하는 회사에 지친 B팀은 새로운 방식의 함수를 만듭니다.

바로 함수를 매겨변수로 받는 함수입니다.

여기서 **매개변수로 지정된 함수**를 콜백 함수라고 합니다.

그렇다면 코드는 이렇게 바뀔 수 있겠지요

```js
function foo(callback) {
  callback();
}
```

이제 B팀은 더 이상 어떤 팀이 추가되든 함수를 변경할 필요가 없습니다.

## 2.5.3 비동기 콜백

콜백을 추가한 것만으로는 모든 문제가 해결되지 않습니다. foo 함수가 실행 완료될 때까지 30분이 걸린다고 가정해봅시다.
foo 함수 이후의 모든 실행은 30분 이후에나 실행 **시작**이 가능합니다. 매우 비효율적입니다.

그러나 저희는 스레드를 통해 비동기적으로 함수를 실행할 수 있다는 것을 배웠죠!

이렇게 foo 함수를 변경하면 30분동안 다른 코드들도 실행시킬 수 있습니다.

```js
// 간소화된 코드입니다.
function foo(callback) {
  thread t(callback())
}
```

이렇게 호출 스레드가 콜백 함수 실행에 의존하지 않는 형태를 비동기 콜백이라고 지힝합니다.

## 2.5.4 비동기 콜백은 새로운 프로그래밍 사고방식으로 이어진다

콜백 함수가 흥미로운 점은 콜백을 실행시키는 함수가 어떤 콜백이 들어올지 예상할 수 없다는 점입니다. 기껏해봐야 어떤 타입의 함수일 것이다 정도인 것이지요. 이런 예상도 동기와 비동기에서도 차이가 발생합니다.

왜냐하면 동기 콜백에서는 하나의 스레드가 모든 실행을 관리하지만 비동기 콜백은 두 개 이상의 스레드가 실행 흐름을 관리하기 때문입니다.

예를 들어 동기 콜백에서는 호출 스레드가 모든 실행을 주관하지만 비동기 콜백에서는 호출 스레드는 말 그대로 호출만 할뿐 실질적인 실행은 다른 스레드에서 진행됩니다.

## 2.5.5 콜백 함수의 정의

앞서 말했던 것처럼 콜백 함수란

> 다른 코드에서 매개변수로 전달되는 실행가능한 코드를 의미합니다.

이는 소프트웨어 설계상의 개념으로 프로그래밍 언어의 특성과는 무관합니다.

## 2.5.6 두 가지 콜백 유형

동기 콜백은 블로킹 콜백이라고 불립니다. 블로킹 콜백이라고 불리는 이유는 라이브러리 함수와 콜백 함수의 실행이 완료될 때까지 다른 함수의 실행이 막히기 때문입니다.

반면에 비동기 콜백은 라이브러리 함수가 실행 중이라도 다른 함수의 실행이 막히지 않습니다. 이런 특성 때문에 비동기 콜백은 입출력 작업에서 자주 볼 수 있으며 웹 서비스처럼 동시성이 높은 시나리오에 적합합니다.

## 2.5.7 비동 콜백의 문제: 콜백 지옥

그러나, 비동기 콜백도 문제가 있습니다. 바로 작동 방식을 온전히 이해하기가 까다롭다는 것이지요. 중첩된다는 특성떄문에 흔히 말하는 콜백 지옥에 빠질 가능성이 높습니다.

그렇다면 비동기 콜백의 효울성을 누리면서도 동기 콜백의 코드 단순성과 가독성을 함께 누릴 수 있는 방법은 없을까요?
그 방법이 바로 2.4장에서 설명한 코루틴입니다. 이에 대한 자세한 설명은 2.8장에서 이어집니다.
