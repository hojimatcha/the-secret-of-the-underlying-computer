# 2.1 운영체제, 프로세스, 스레드의 근본 이해하기

## 2.1.1 모든 것은 CPU에서 시작된다.

컴퓨터에서 뇌를 담당하는 CPU는 사실 매우 간단한 일만 할 수 있습니다.

1. 메모리에서 명령어를 하나 가져옵니다.
2. 이 명령어를 실행한 후 다시 1로 돌아갑니다.

하지만 위 작업을 ms 단위로 할 수 있기에 대단한 것이지요.

그리고 CPU는 PC 레지스터에 저장된 명령어 주소에 따라 메모리에 저장된 명령어를 실행합니다.
다시 말하자면 CPU는 어떤 명령어를 실행해야할지 PC 레지스터에 따라 결정된다는 의미입니다.

> 혹시 C 언어에서 main 함수를 작성해본 적이 있나요?
> main 함수는 PC 레지스터에 기록되는 첫 번째 기계 명령어로 진입점으로 사용됩니다.

## 2.1.2 CPU에서 운영 체제까지

CPU가 일을 하려면 다음과 같은 절차가 선행되어야 합니다. 먼저 실행 파일을 수동으로 메모리에 복사한 후 main 함수에 해당하는 첫 번째 기계 명령어를 메모리에서 찾아 그 주소를 PC 레지스터에 적재합니다. 그리고 위 작업은 운영 체제가 모두 처리해줍니다.

> 운영 체제는 CPU가 일할 수 있는 환경을 꾸려준다.

혹시 CPU는 한번에 한 가지 일을 할 수 있다는 게 이상하게 들리진 않았나요? 저희는 노래를 들으면서 웹 서핑도 하고 게임도 하는데 이런 멀티 테스킹은 어떻게 가능할까요?

이는 **상황 정보**라는 개념덕분에 가능합니다. CPU는 여러 프로그램이 있을 때 한 프로그램이 끝날 때까지 명령어를 실행하는 것이 아니라 한 명령어를 실행한 후에 다른 프로그램에 가서 또 다른 명령어를 실행하고 이를 계속해서 반복합니다. 그리고 상황 정보가 이전 작업 환경을 모두 저장하고 있기 때문에 다른 작업을 수행하고 돌아와서도 이어서 수행하는 것이 가능한 것이지요

그리고 이런 수행중인 프로그램을 프로세스라고 명명합니다.

## 2.1.3 프로세스는 매우 훌륭하지만, 아직 불편하다

프로세스는 CPU가 여러 작업을 동시에 작업하는 것처럼 보이게 하지만 완벽하진 않습니다. 왜냐하면 프로세스끼리는 환경을 공유하지 않기 때문이죠. 예를 들어, A와 B 프로세스가 있고 B가 A의 결과물을 사용해야한다면 B는 꼼짝없이 A의 작업이 모두 수행될 때까지 기다려야 합니다.

이걸 **다중 프로세스 프로그래밍**이라고 합니다. 다중 프로세스 프로그래밍은 유용하기도 하지만 단점도 있습니다.

1. 프로세스를 생성할 때 비교적 큰 오버헤드가 발생합니다.
2. 프로세스마다 자체적인 주소 공간을 가지고 있기 때문에 프로세스 간 통신은 프로그래밍하기에 더 복잡합니다.

이를 해결 하기위해 스레드가 탄생합니다.

## 2.1.4 프로세스에서 스레드로 진화

스레드는 프로세스와 달리 독립적인 주소 공간을 가지고 있지 않기에 통신이 필요하지 않습니다. 다시 말해서 각 스레드는 다른 스레드의 주소 공간을 참조할 수 있습니다. 즉, 고성능의 동시성을 가질 수 있다는 말이죠

## 2.1.5 다중 스레드와 메모리 구조

스레드가 존재하기 이전 프로세스에는 단 하나의 실행 흐름과 스택 영역이 있었습니다.
그러나, 스레드 개념이 생겨난 후에는 하나의 프로세스에 여러 실행 진입점이 존재할 수 있게 되었고 동시에 실행 흐름도 여러 개를 가질 수 있게 되었습니다.

> 스레드마다 스택 영역이 하나씩 있어야 합니다. 실행 환경이 저장되어야 하기 때문이죠.

## 2.1.6 스레드 활용 예

스레드가 처리해야하는 작업은 긴 작업과 짧은 작업으로 나눌 수 있습니다. 긴 작업이란 스레드의 수명이 프로세스의 수명과 비슷한 작업을 의미하며 짧은 작업은 네트워크 요청 등 처리 시간이 짧은 작업을 의미합니다.

> 긴 작업은 시간이 오래 걸리지만 요청 수가 적고 짧은 작업은 작업 시간이 짧지만 요청 수가 많다는 특징이 있습니다.

작업 유형을 알아야하는 이유는 스레드 생성 방식과 관련이 있기 때문입니다. 스레드가 흔히 생성되는 방식 중에 **요청당 스레드**라는 것이 있습니다. 이는 요청이 들어올 때마다 매번 스레드가 생성된다는 의미로, 긴 작업 대상으로는 매우 효율적이지만 짧은 작업에서는 비효울적입니다.

이유는 다음과 같습니다.

1. 스레드의 생성과 종료에 많은 시간이 소모됩니다.
2. 스레드마다 독립적인 스택 영역이 필요한데, 많은 수의 스래드를 생성하면 메모리와 기타 시스템 리소스를 너무 많이 소모합니다.
3. 스레드 수가 많으면 스레드 간 전환에 따른 부담이 증가합니다.

이를 해결하기 위헤 스레드 풀이 탄생합니다.

# 2.1.7 스레드 풀의 동작 방식

스레드 풀은 공장에 비유해서 설명할 수 있습니다. 공장에서 간단하고 쉬운 작업을 처리하는 근로자가 있습니다. 이 한번의 작업을 위해서 매번 고용하고 해고하는 것이 요청당 스레드 방식이라고 한다면 스레드 풀 방식은 한 명의 근로자가 작업을 하되 작업을 진행하진 않을 때 쉬게하는 방식입니다.

내부적으로 스레드 풀 방식은 큐를 이용해서 구현되며 작업을 전달하는 생상자와 작업을 처리하는 소비자로 구분됩니다.

# 2.1.8 스레드 풀의 스레드 수

스레드 풀의 스레드 수가 너무 적다면 CPU를 최대한 활용할 수 없으며, 너무 많은 스레드를 생성하면 반대로 시스템의 성능 저하가 생길 수 있기 때문에 스레드 수는 적지도 많지도 않아야 합니다.

그리고 필요한 스레드 수의 계산은 CPU 집약적인 작업과 입출력 집약적인 작업으로 구분할 수 있습니다. 이 두 개의 계산 방법이 다르기 때문에 구체적인 상황과 그에 대한 분석에 따라 스레드 수를 결정하는 것이 중요합니다.
