## 2.3 스레드 안전 코드는 도대체 어떻게 작성해야 할까?

들어가기 전, 2장에서 배울 수 있는 것들에 대해 소개합니다.

- OS(운영체제)는 왜 필요한지
- 프로세스, 스레드, 코루틴의 개념
- 콜백함수, 동기화, 비동기화, 블로킹, 논블로킹의 개념
- 이런 개념들을 왜 이해해야 하고, 무엇을 할 수 있으며, 기계 성능 활용 측면에서 어떻게 다루면 좋은지 알아봅니다.

### 2.1 Recap: 운영체제, 프로세스, 스레드의 근본 이해하기

- **CPU는 한 번에 하나의 일만 할 수 있습니다.**
- **CPU는 명령어를 가져와 실행하는 간단한 기능만 수행합니다.**
  > 프로그램 카운터(PC, Program Counter) 라는 레지스터는 다음에 가져올 명령어의 주소를 저장합니다.(CPU용 메모리)<br>
  > 최초의 PC레지스터 값은 main 함수에 대응하는 첫번째 기계 명령어입니다.<br>
- **운영체제가 하는 일은 다음과 같습니다.**
  > 프로그램을 적재할 수 있는 적절한 크기의 메모리 영역을 찾고 적재하는 일(loader)<br>
  > CPU 레지스터를 초기화 하고 함수의 진입포인트를 찾아 PC레지스터를 설정하는 일<br>
  > 각 프로그램의 상태값(context)을 저장하고 실행하는 일<br>
- **프로그램을 실행하면 프로그램의 상태 정보를 저장하는 구조체를 형성하고, 프로그램의 현재 실행 상태를 저장하는데 이를 프로세스라 합니다.**
- **CPU가 멀티 태스킹을 지원하는 방식에는 두 가지 방식이 있습니다.**
  1. 다중 프로세스 방식 (multi-process)
     > 여러 개의 프로세스를 생성하는 방식입니다.<br>
     > 하나의 CPU로도 여러개의 프로그램을 빠르게 번갈아가며 실행하여 동시에 여러 개를 처리하는 것과 같이 보이게 하는 눈속임(시분할 방식)입니다.<br>
     > 프로세스 생성 시 프로그램의 상태 정보를 저장하는 context를 생성합니다. > 오버헤드 발생 가능성이 높아집니다.<br>
     > 운영체제의 스케줄링에 따라 문맥변경(context switching)을 합니다.<br>
     > 각 프로세스마다 별도의 메모리 공간을 갖고 있어, 문맥 변경 시 주소 공간 교체가 필요하고 이에 따라 IPC(프로세스 간 통신)시 큰 비용이 듭니다.<br>
  2. 멀티 스레드 방식 (multi-thread)
     > 단일 프로세스 내에서 여러개의 실행흐름(thread)을 생성하고 실행하는 방식입니다.<br>
     > 동일한 메모리 공간을 사용합니다. 이때, 오류 발생 가능성이 있어 상호배제와 동기화를 사용하여 해결해야 합니다.<br>
     > 여러 개의 CPU에서 동시에 하나의 프로세스에 대한 작업 수행합니다.<br>

> [!TIP] > **그럼 CPU가 1개일 때는 multi-thread 사용이 불가능한가요?**<br>
> 아니요, CPU가 1개라도 멀티스레드 방식에서는 여러개의 작업을 하는 것 처럼 보이는 시분할 방식을 사용합니다.<br>
> 그렇다면 다중 프로세스 방식의 시분할 방식과 멀티 스레드 방식의 시분할 방식은 어떤 차이가 있을까요?<br>
> 바로, 문맥 전환 대상이 다르다는 데에 있습니다.<br>
> | |multi-process|multi-thread|
> |------|---|---|
> |문맥 전환 대상|프로세스 단위|스레드 단위|
> |주소 공간 변경|필요, 각 프로세스의 메모리 상태(스택, 레지스터 등)를 전부 저장하고 복원|불필요, 스레드 간 메모리 공간 공유|
> |문맥 전환 비용|OS가 프로세스 주소공간을 변경해야 하므로 비용이 큼|주소 공간 변경이 없어 비용이 낮음|

- **스레드의 life cycle에 따라**

  > 1.  long task<br>
  >
  > - 프로세스의 life cycle과 거의 유사한 경우<br>
  > - 요청 당 스레드 방식으로 유의미하게 동작<br>
  >
  > 2.  short task<br>
  >
  > - 작업 처리 시 필요한 시간이 짧고, 작업 수가 많은 특징<br>
  > - 요청 당 스레드 방식으로 처리 시, 비 효율적으로 동작하므로 스레드 풀(thread pool)이 등장<br>

- **스레드 풀(thread pool)**
  > 미리 스레드를 여러 개 생성 해두고 생성해 둔 스레드를 재사용하는 방식입니다.<br>
  > 일정한 갯수의 스레드로 작업을 관리하므로 불필요한 메모리 소비를 하지 않습니다.<br>
  > 필요한 리소스에 따라,
  >
  > 1. CPU 집약적 작업
  >
  > - 외부 입출력에 의존하지 않고 연산하는 작업
  > - 보통 CPU 코어 수와 동일하게 스레드 수를 할당
  >
  > 2. 입출력 집약적 작업
  >
  > - 연산보다 디스크 입출력 및 네트워크 입출력에 시간을 소비하는 작업
  > - 적절한 스레드 수: $N \times \left( 1 + \frac{WT}{CT} \right)$
  > - N: CPU 코어 수
  > - WT: Wait Time (입출력 대기 시간)
  > - CT: Computing Time (CPU 연산에 필요한 시간)

### 2.2 Recap: 스레드 간 공유되는 프로세스 리소스

- **스레드 전용 리소스 vs 공유 리소스**
  > 1. 스레드 전용 리소스
  >
  > - thread local storage
  > - PC register, stack pointer, 실행 시 register 의 정보
  >
  > 2. 공유 리소스
  >
  > - 코드 영역(read-only)
  > - 힙 영역 (동적 데이터)
  > - 데이터 영역 (전역변수)
  > - 스택 영역의 경우, 실제로 스레드 별로 스택이 형성되기는 하나 완전히 보호되지는 않습니다.

> [!TIP] 스레드 스택 영역<br>
> 각 스레드는 스택 영역에 자신만의 runtime stack frame을 형성하므로, 이는 스레드 전용 리소스 같기도 합니다.<br>
> 하지만 그렇게 분류를 하기엔 어려운 점은, 포인터만 획득한다면 다른 스레드에서 접근하여 변수를 변경하는 것이 가능하기 때문입니다.<br>
> 스택 프레임 간의 보호장치가 되어 있지 않으므로 이런 동작이 가능합니다.<br>

- 스레드 전용 저장소(thread local storage)
  > `__thread` 키워드와 함께 선언되는 변수들은 모두 스레드 전용 저장소에 저장됩니다.<br>
  > 모든 스레드에서 접근 가능합니다<br>
  > 변수가 초기화 된 복사본을 각 스레드에서 연산하므로, 다른 스레드에 영향을 끼치지 않습니다.<br>
  >
  > ```
  > __thread int a = 1;
  >
  > void print_a() {
  >   cout << a << endl;
  > }
  >
  > void run() {
  >   ++a;
  >   print_a();
  > }
  >
  > void main() {
  >   thread t1(run); // 스레드 복사본 a = 1에서 ++a 연산 후 2 출력
  >   t1.join(); //t1 스레드가 실행될 때 까지 기다림
  >
  >   thread t2(run); // 스레드 복사본 a = 1에서 ++a 연산 후 2 출력
  >   t2.join(); //t2 스레드가 실행될 때 까지 기다림
  >   print_a(); // 1이 출력
  > }
  > ```
  >
  > 여기에서 전역공간에 선언된 `__thread` 변수는 마치 전역변수처럼 모든 스레드에서 접근할 수 있지만<br>
  > 실제 전역변수의 값에는 접근하지 못하여, 변경할 수 없습니다. 스레드 내 지역변수처럼 사용됩니다.<br>

<br>
<br>

## 2.3 스레드 안전 코드는 도대체 어떻게 작성해야 할까?

### 2.3.1 자유와 제약

<br>

멀티 스레드는 메모리 영역을 공유하기 때문에 낮은 비용으로 빠른 문맥전환을 할 수 있지만, 공유 리소스에 접근하여 변수를 변경하는 등 버그의 위험이 있을 수 있습니다.<br>
따라서 멀티 스레드 코드는 스레드 안전(thread safety)을 지키며 작성해야 합니다.<br>
스레드 안전은 **특정 스레드가 다른 스레드의 공유 리소스 사용 순서를 방해하지 않음**으로서 달성할 수 있습니다.<br>

> [!NOTE] 스레드 안전을 달성하기
>
> - 전용 리소스를 사용하는 스레드
> - 공유 리소스를 사용하는 스레드의 경우, 대기 제약 조건에 맞게 공유 리소스를 사용

### 2.3.2 스레드 안전이란 무엇일까?

<br>

스레드 안전이란, 몇 개의 스레드에서 호출이 되든 또 어떤 순서로 호출이 되든 간에 상관없이 올바른 결과가 나오는 코드를 의미합니다.<br>
따라서 모든 스레드가 공유할 수 있는 리소스에서 언제 **스레드 전용 리소스**를 사용하는지 **공유 리소스**를 사용하는 지 구분해야 합니다.<br>

### 2.3.3 스레드 전용 리소스와 공유 리소스

<br>

1.  스레드 전용 리소스

- 함수의 지역변수 - 각 스레드의 스택영역(runtime stack frame)에 적재되었다가 함수 실행 종료 시 사라지는 변수
- 스레드의 스택 영역
- 스레드 전용 저장소

2.  공유 리소스

- 힙 영역
- 데이터 영역
- 코드 영역

공유 리소스는 주로 변수가 저장되는 영역, 즉 힙 영역(메모리 동적 할당으로 지정된 데이터)과 데이터 영역(전역 데이터)으로 구성됩니다.<br>
공유 리소스를 사용하는 스레드들은 반드시 **순서**를 따라야 합니다. 이를 위해 lock, semaphore 와 같은 장치를 사용합니다.<br>

> [!TIP] lock 과 semaphore
>
> 1. 잠금 (lock)
>    상호배제(mutual exclusion), 한 번에 오직 하나의 스레드만 공유 리소스에 접근하도록 제한하는 방식<br>
>    lock을 획득한 스레드만 공유 리소스를 사용하고, 다른 스레드는 lock이 해제 될 때 까지 대기<br>
>    한 스레드만 접근해야 하는 경우 사용(계좌 이체, 파일 쓰기 등)
>
> 2. 세마포어 (semaphore)
>    동시에 여러 개의 스레드가 공유 자원을 사용할 수 있도록 제한된 방식<br>
>    일정 개수만큼의 스레드만 동시 접근 가능<br>
>    제한된 개수의 리소스를 여러 스레드가 공유해야 하는 경우(DB 연결, 네트워크 요청 등) 사용

<br>

### 2.3.4 스레드 전용 리소스만 사용하기 & 2.3.5 스레드 전용 리소스와 함수매개변수

<br>

별다른 조치를 취하지 않고도 스레드 안전을 지키는 함수는 다음 2가지 입니다.

1. 무상태 함수

- 전역변수나 매개변수에 의존하지 않는 함수
- 스레드 전용 리소스인 지역변수만 사용
- 우리가 흔히 아는 순수함수

2. call by value 로 매개변수를 전달받는 함수

- 매개변수는 스레드 스택 프레임(스택 영역)에 저장되어 스레드 전용 리소스가 됩니다.

> [!TIP] call by value
> 인자 전달 시 원본 값을 복사하여, 새로운 지역변수로 저장합니다.
> 이렇게 저장된 지역변수는 스레드 전용 리소스로, 스택 영역에서 함수 실행과 함께 쌓였다가 종료 시 사라지는 로컬 변수 동작과 같습니다.
> 원본 변수의 변경 없이, 함수 내 독립적인 스택에서 복사본을 생성하여 사용합니다.

<br>

포인터를 사용하여 매개변수를 전달하게 되면 스레드 안전을 지킬 수 없습니다.

```cpp
//예시1
#include <iostream>
#include <thread>

using std::endl;
using std::cout;
using std::thread;

int global_num = 1; // 공유 리소스(데이터 영역, 전역 변수)

void func(int* num) {
  cout << "func 실행중, num의 주소: " << num << ", 값: " << *num << endl;
    ++(*num);  // 여기서 여러 스레드가 동시에 수정하면 충돌 발생 가능
}

void multi_thread() {
  cout << "thread 실행" << endl;
  func(&global_num);
}

int main() {
  thread thread1(multi_thread);
  thread thread2(multi_thread);

  thread1.join();
  thread2.join();

  return 0;
}
```

위와 같은 경우, 스레드가 동시에 실행되면 데이터 레이스 현상이 일어날 수 있습니다. <br>
각 스레드가 읽은 global_num 값이 같을 수도 있기 때문에 연산된 값을 덮어 씌울 수 있게 됩니다.<br>
따라서 저자는 여기에서 **모든 스레드가 func 함수를 호출할 때 해당 스레드에 속하는 리소스 주소를 전달하여 해결할 수 있다**고 이야기합니다. <br>
이는 즉 아래와 같이 해결하자는 겁니다.

```cpp
//예시 2
#include <iostream>
#include <thread>

using std::endl;
using std::cout;
using std::thread;

void func(int* num) {
  cout << "func 실행중, num 주소: " << num << ", 값: " << *num << endl;
  ++(*num);
}

void multi_thread() {
  int thread_local_num = 1;  // 각 스레드마다 독립적인 변수 사용
  func(&thread_local_num); //스레드마다 다른 리소스 주소 전달
  cout << "스레드 내 최종 num 값: " << thread_local_num << " (주소: " << &thread_local_num << ")" << endl;
}

int main() {
  thread thread1(multi_thread);
  thread thread2(multi_thread);

  thread1.join();
  thread2.join();

  return 0;
}
```

각각의 실행결과를 보면, 변경된 코드는 다른 메모리 주소값을 갖고 있음을 볼 수 있습니다.

```
[예시 1 실행결과]
thread 실행
func 실행중, num의 주소: 0x56392d301010, 값: 1
thread 실행
func 실행중, num의 주소: 0x56392d301010, 값: 2
```

```
[예시 2 실행결과]
func 실행중, num 주소: 0x7f83a5ae2df4, 값: 1
스레드 내 최종 num 값: 2 (주소: 0x7f83a5ae2df4)
func 실행중, num 주소: 0x7f83a64e3df4, 값: 1
스레드 내 최종 num 값: 2 (주소: 0x7f83a64e3df4)
```

### 2.3.6 전역변수 사용

전역 변수를 사용하면 무조건 스레드 안전 코드가 아닐까요? <br>
만약 선언된 전역변수를 **읽기만** 한다면 이는 스레드 안전을 보장합니다. <br>
하지만 전역변수를 변경할 수 있는 함수가 있다면, 그 함수는 스레드 안전 함수가 아니게 됩니다.<br>

### 2.3.7 스레드 전용 저장소

`__thread`키워드를 붙여 선언하고 로그결과를 보겠습니다.

```cpp
#include <iostream>
#include <thread>

using std::endl;
using std::cout;
using std::thread;

__thread int global_num = 1;  // 스레드 로컬 저장소 (각 스레드마다 독립적인 변수)

int func() {
  cout << "스레드 내 global_num 주소: " << &global_num << ", 값: " << global_num << endl;
  ++(global_num);
  cout << "업데이트 후 global_num 값: " << global_num << ", 주소: " << &global_num << endl;
  return global_num;
}

int main() {
  thread thread1(func);
  thread thread2(func);

  thread1.join();
  thread2.join();

  // main 스레드에서는 global_num에 대한 주소를 출력
  cout << "메인 스레드의 global_num 주소: " << &global_num << ", 값: " << global_num << endl;

  return 0;
}
```

```
스레드 내 global_num 주소: 0x7f3322bf76bc, 값: 1
업데이트 후 global_num 값: 2, 주소: 0x7f3322bf76bc
스레드 내 global_num 주소: 0x7f33235f86bc, 값: 1
업데이트 후 global_num 값: 2, 주소: 0x7f33235f86bc
메인 스레드의 global_num 주소: 0x7f33235f973c, 값: 1
```

각 스레드 내 `global_num` 주소값이 다른 것을 볼 수 있습니다. 즉 스레드 전용 저장소에 선언된 변수는 각 스레드에 서로 다른 주솟값을 전달하여 스레드 안전을 보장합니다.

### 2.3.8 함수 반환 값

- 값을 반환하는 경우 스레드 안전
- 포인터를 반환하는 경우 스레드 안전하지 않은데, 이에 대한 예시를 소개합니다.

```c
int* func() { //함수의 포인터를 반환하는 func 함수 정의
  static int a = 100; //정적 지역 변수 a 의 값은 100, 초기화
  return &a; //정적 지역변수 a의 메모리 주소를 반환
}
```

이렇게 변수의 주소를 반환하면 잠재적 스레드 공유 리소스가 되어, 해당 주소를 획득한 스레드는 변수에 접근이 가능하므로 스레드 안전을 보장할 수 없게 됩니다. <br>
이를 사용하여 싱글톤 패턴을 구현할 수도 있습니다.<br>

> [!TIP] static 선언 유무의 차이
>
> ```c
> int func() {
>   int a = 100;
>   return &a;
> }
> ```
>
> 위의 경우, 정적 변수를 사용하지 않으므로 함수 종료와 함께 a의 메모리는 해제됩니다.<br>
> 따라서 반환된 주소는 유효하지 않게 되고, 해당 메모리 공간은 재사용 되거나 덮어 씌워지므로 해당 주소를 계속해서 사용할 시 알 수 없는 동작을 하게 됩니다.

### 2.3.9 스레드 안전이 아닌 코드 호출하기

1. 스레드 안전을 보장하지 않는 코드를 스레드 안전 코드로 만들 수 있는 방식이 있습니다. 바로 안전장치를 사용하는 것입니다.

```cpp
#include <iostream>
#include <thread>
#include <mutex>

// 전역 변수
int num = 0;

// 뮤텍스 객체
std::mutex mtx;

// 공유 자원에 접근하는 함수
void func() {
  // 뮤텍스를 잠급니다
  mtx.lock();

  // 공유 자원을 수정
  num++;
  std::cout << "현재 공유 자원 값: " << num << std::endl;

  // 잠금 해제
  mtx.unlock();
}

int main() {
  std::thread thread1(func); //1
  std::thread thread2(func); //2

  thread1.join();
  thread2.join();

  std::cout << "최종 공유 자원 값: " << num << std::endl;

  return 0;
}
```

이와 같이 적절한 순서에 따라 처리할 수 있도록 하면, 안전하지 않은 코드도 스레드 안전을 보장할 수 있습니다.

2. 동작 방식에 따라 스레드 안전 함수가 아닌데도 불구하고 스레드 안전 코드로 사용할 수 있습니다.

```cpp
int func(int *num) {
  ++(*num);
  return *num;
}

void execFunc() {
  int a = 100;
  int b = func(&a);
}
```

실제로 `func`함수의 매개변수로 전달된 포인터가 전역변수를 가리킬 수도 있기에 스레드 안전이 아니라고 생각하게 됩니다.<br>
그러나 실제로 전달되는 매개변수가 지역변수이므로 `execFunc`를 호출하는 스레드가 몇 개 이든 서로 간섭하지 않게 됩니다.<br>

### 2.3.10 스레드 안전 코드는 어떻게 구현할까?

스레드 안전을 보장하기 위해서는 어떤 리소스라도 최대한 공유하지 않는 것이 원칙입니다.<br>

- 스레드 전용 저장소 (thread local storage): 전역 리소스를 사용해야 한다면 스레드 전용 저장소로 선언할 수 있는지 확인하세요.
- 읽기 전용 (read-only): 전역 리소스를 반드시 사용해야 한다면, 읽기 전용으로 사용해도 되는지 확인합니다.
- 원자성 연산 (atomic operation): std::atomic 형식의 변수를 사용합니다. 원자성 연산은 도중에 중단되지 않습니다.
- 동기화 시 상호 배제 (mutual exclusion in synchronization): 결국 스레드 간 공유가 필요하다면, 공유 리소스 순서를 프로그래머가 관리해주어야 합니다. <br>
mutex, spin lock, semaphore 등의 동기화 시 상호배제 작업을 통해 스레드 안전을 보장하도록 합니다.

